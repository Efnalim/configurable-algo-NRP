<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nsp_solver.solver.nsp_cplex API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nsp_solver.solver.nsp_cplex</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python

import itertools
import math

import cplex

from nsp_solver.solver.nsp_solver import NSP_solver
from nsp_solver.utils import utils


class CplexSolver(NSP_solver):
    &#34;&#34;&#34;Child Class from NSP_solver that uses MILP cplex solver via API to compute a schedule per week.
    &#34;&#34;&#34;
    name = &#39;CPLEX&#39;

    def prepare_help_data(self, data, results):
        &#34;&#34;&#34;Prepares helpful data for other methods.

        Args:
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule
        &#34;&#34;&#34;
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;] = list(
            map(lambda x: int(x.split(&#34;_&#34;)[1]), data[&#34;wd_data&#34;][&#34;vacations&#34;])
        )

        results[(week_number, &#34;status&#34;)] = utils.STATUS_FAIL

    def init_ilp_vars(self, model, data):
        &#34;&#34;&#34;
        Initializes basic variables for primarly for hard contraints.

        Args:
            model: object that represents the mathematical model
            data (dict): dictionary that contains data from input files

        Returns:
            dict: dictionary &#39;basic_ILP_vars&#39; that contains the names variables of the mathematical model
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        all_skills = data[&#34;all_skills&#34;]
        num_days = data[&#34;num_days&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

        # Creates shifts variables.
        # shifts[n][d][s]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; if 1 does not work if 0.
        vars_to_add = []
        shifts = []
        for n in all_nurses:
            shifts.append([])
            for d in all_days:
                shifts[n].append([])
                for s in all_shifts:
                    var_name = f&#34;shift_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    shifts[n][d].append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Creates working_days variables.
        # shifts[n][d][s]: nurse &#39;n&#39; works on day &#39;d&#39; if 1 does not work if 0.
        vars_to_add = []
        working_days = []
        for n in all_nurses:
            working_days.append([])
            for d in all_days:
                var_name = f&#34;work_day_n{n}_d{d}&#34;
                working_days[n].append(var_name)
                vars_to_add.append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Creates shifts_with_skills variables.
        # shifts_with_skills[(n, d, s, sk)]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; with skill &#39;sk&#39;.
        vars_to_add = []
        shifts_with_skills = []
        for n in all_nurses:
            shifts_with_skills.append([])
            for d in all_days:
                shifts_with_skills[n].append([])
                for s in all_shifts:
                    shifts_with_skills[n][d].append([])
                    for sk in all_skills:
                        var_name = f&#34;shift_with_skill_n{n}_d{d}_s{s}_sk{sk}&#34;
                        vars_to_add.append(var_name)
                        shifts_with_skills[n][d][s].append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        not_working_days = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;not_working_day_n{n}_d{d}&#34;
                not_working_days[(n, d)] = var_name
                vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [not_working_days[(n, d)], working_days[n][d]], [1, 1]
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[1],
                )

        vars_to_add = []
        not_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = f&#34;not_workingshift_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    not_working_shifts[(n, d, s)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [not_working_shifts[(n, d, s)], shifts[n][d][s]], [1, 1]
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[1],
                    )

        # Vars for each nurse how many days they worked
        vars_to_add = []
        total_assignments = {}
        for n in all_nurses:
            var_name = f&#34;total_assignments_n{n}&#34;
            total_assignments[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[num_days + 1] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments[(n)]]
                        + [shifts[n][d][s] for d in all_days for s in all_shifts],
                        [-1]
                        + [1]
                        * len([shifts[n][d][s] for d in all_days for s in all_shifts]),
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

        # Vars for each nurse n indicationg if they were working on weekend this week
        vars_to_add = []
        working_weekends = {}
        for n in all_nurses:
            var_name = f&#34;working_weekends_n{n}&#34;
            working_weekends[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        incomplete_weekends = {}
        for n in all_nurses:
            var_name = f&#34;incomplete_weekends_n{n}&#34;
            vars_to_add.append(var_name)
            incomplete_weekends[(n)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            isCompleteWeekendRequested = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;completeWeekends&#34;]
            if isCompleteWeekendRequested == 1:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                incomplete_weekends[(n)],
                                working_weekends[(n)],
                                working_days[n][5],
                                working_days[n][6],
                            ],
                            [-1, 2, -1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

        basic_ILP_vars = {}
        basic_ILP_vars[&#34;working_days&#34;] = working_days
        basic_ILP_vars[&#34;incomplete_weekends&#34;] = incomplete_weekends
        basic_ILP_vars[&#34;total_assignments&#34;] = total_assignments
        basic_ILP_vars[&#34;working_weekends&#34;] = working_weekends
        basic_ILP_vars[&#34;not_working_days&#34;] = not_working_days
        basic_ILP_vars[&#34;not_working_shifts&#34;] = not_working_shifts
        basic_ILP_vars[&#34;shifts&#34;] = shifts
        basic_ILP_vars[&#34;shifts_with_skills&#34;] = shifts_with_skills
        return basic_ILP_vars

    def add_shift_succession_reqs(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;
        Adds hard constraint that disables invalid pairs of succcessive shift types.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        num_days = data[&#34;num_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            if last_shift == 2:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][0][last_shift - 1], shifts[n][0][last_shift - 2]],
                            [1] * 2,
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )
            if last_shift == 3:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                shifts[n][0][last_shift - 1],
                                shifts[n][0][last_shift - 2],
                                shifts[n][0][last_shift - 3],
                            ],
                            [1] * 3,
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

            for d in range(num_days - 1):
                for s in all_shifts:
                    if s == 2:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        shifts[n][d][s],
                                        shifts[n][d + 1][s - 1],
                                        shifts[n][d + 1][s - 2],
                                    ],
                                    [1] * 3,
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[1],
                        )
                    if s == 3:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        shifts[n][d][s],
                                        shifts[n][d + 1][s - 1],
                                        shifts[n][d + 1][s - 2],
                                        shifts[n][d + 1][s - 3],
                                    ],
                                    [1] * 4,
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[1],
                        )

    def add_missing_skill_req(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds hard constraint that disables nurses working shift with a skill that they do not possess.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        all_skills = data[&#34;all_skills&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

        for n, nurse_data in enumerate(nurses_data):
            for sk in all_skills:
                has_skill = False
                for skill in nurse_data[&#34;skills&#34;]:
                    if sk == utils.skill_to_int[skill]:
                        has_skill = True
                        break
                if has_skill is False:
                    for d in all_days:
                        for s in all_shifts:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair([shifts_with_skills[n][d][s][sk]], [1])
                                ],
                                senses=[&#34;E&#34;],
                                rhs=[0],
                            )

    def add_hard_constrains(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds all hard constraints to the model.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        if data[&#34;configuration&#34;][&#34;h1&#34;]:
            self.add_max_one_shift_per_day_constraint(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h2&#34;]:
            self.add_shift_skill_req_minimal(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h3&#34;]:
            self.add_shift_succession_reqs(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h4&#34;]:
            self.add_missing_skill_req(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h5&#34;]:
            self.add_max_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
            self.add_max_consecutive_work_shifts_constraint_hard(
                model, basic_ILP_vars, data
            )
            self.add_min_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
            self.add_min_consecutive_shifts_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h6&#34;]:
            self.add_max_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)
            self.add_min_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h7&#34;]:
            self.add_max_incomplete_weekends_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h8&#34;]:
            self.add_max_min_total_assignments_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h9&#34;]:
            self.add_min_continuous_free_period_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h10&#34;]:
            self.add_max_one_shift_per_day_exception_constraint_hard(
                model, basic_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;h11&#34;]:
            self.add_max_shift_of_given_type_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h12&#34;]:
            self.add_vacations_reqs_constraint_hard(model, basic_ILP_vars, data)

    def add_max_incomplete_weekends_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

        for n in all_nurses:
            incomplete_weekends_prev = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfIncompleteWeekends&#34;
            ]
            max_incomplete_weekends = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfIncompleteWeekendsHard&#34;]
            model.linear_constraints.add(
                lin_expr=[cplex.SparsePair([incomplete_weekends[(n)]], [1])],
                senses=[&#34;L&#34;],
                rhs=[max_incomplete_weekends - incomplete_weekends_prev],
            )

    def add_max_one_shift_per_day_constraint(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        # Each nurse works at most one shift per day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(shifts[n][d][:], [1] * len(shifts[n][d][:]))
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

        # Each nurse works at most one skill per shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                shifts_with_skills[n][d][s][:],
                                [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

        # If nurse is working with skill that shift, she is working that shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                                [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[0],
                    )

        # If nurse is working with a shift, she is working that day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [-1] + [1] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_max_shift_of_given_type_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that disallows more assignments to a specific shift type than it is allowed.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        num_days = data[&#34;num_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            already_assigned = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numbersOfAssignedRestrictedShiftTypes&#34;
            ]
            for restriction in data[&#34;sc_data&#34;][&#34;nurses&#34;][n][&#34;restrictions&#34;]:
                shift_id = utils.shift_to_int[restriction[&#34;type&#34;]]
                limit = restriction[&#34;limit&#34;]
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][d][shift_id] for d in all_days], [1] * num_days
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[limit - already_assigned[shift_id][&#34;numberOfAssignments&#34;]],
                )

    def add_max_one_shift_per_day_exception_constraint_hard(
        self, model, basic_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day with the exception of early and night shifts on the same day.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        # Each nurse works at most one shift per day with an exception early + night.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            shifts[n][d][0: (num_shifts - 1)], [1] * (num_shifts - 1)
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(shifts[n][d][1:num_shifts], [1] * (num_shifts - 1))
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

        # If nurse is working with a shift, she is working that day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [-4] + [1] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[0],
                )
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [1] + [-2] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[0],
                )

        # Each nurse works at most one skill per shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                shifts_with_skills[n][d][s][:],
                                [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

        # If nurse is working with skill that shift, she is working that shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                                [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[0],
                    )

    def add_vacations_reqs_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignments fot a nurse that is has planned a vacation.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        wd_data = data[&#34;wd_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for nurse_id in wd_data[&#34;vacations_with_ids&#34;]:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        working_days[nurse_id][:], [1] * len(working_days[nurse_id][:])
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

    def add_shift_skill_req_minimal(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds hard constraint that dictates minimal number of nurses in a shift working with specific skill.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        for req in data[&#34;wd_data&#34;][&#34;requirements&#34;]:

            s = utils.shift_to_int[req[&#34;shiftType&#34;]]
            sk = utils.skill_to_int[req[&#34;skill&#34;]]
            minimal_capacities_in_week = [
                req[&#34;requirementOnMonday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnTuesday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnWednesday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnThursday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnFriday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnSaturday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnSunday&#34;][&#34;minimum&#34;],
            ]

            for d, min_capacity in enumerate(minimal_capacities_in_week):
                skills_worked = []
                for n in all_nurses:
                    skills_worked.append(shifts_with_skills[n][d][s][sk])
                model.linear_constraints.add(
                    lin_expr=[cplex.SparsePair(skills_worked, [1] * len(skills_worked))],
                    senses=[&#34;G&#34;],
                    rhs=[min_capacity],
                )

    def add_min_continuous_free_period_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that enforces that every nurse has a minimal continuous period of days off.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        num_days = data[&#34;num_days&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
            contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
            min_free_period = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;minimalFreePeriod&#34;]

            vars_to_add = []
            free_periods = {}
            for d in range(num_days - min_free_period + 1):
                var_name = f&#34;free_period_of_{min_free_period}_days_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                free_periods[(n, d)] = var_name
            model.variables.add(
                names=vars_to_add,
                lb=[0] * len(vars_to_add),
                ub=[1] * len(vars_to_add),
                types=[&#34;N&#34;] * len(vars_to_add),
            )

            for d in range(num_days - min_free_period + 1):
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [free_periods[(n, d)]]
                            + working_days[n][d: d + min_free_period],
                            [1] + [1] * min_free_period,
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[0],
                )

                for dd in range(d, d + min_free_period):
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [free_periods[(n, d)]] + [working_days[n][dd]],
                                [1] + [1],
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            free_periods[(n, d)]
                            for d in range(num_days - min_free_period + 1)
                        ],
                        [1] * (num_days - min_free_period + 1),
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[1],
            )

    def add_max_min_total_assignments_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that enforces that total number of assignemnts a nurse are in the limits specified in the contract of the nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignmentsHard&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                &#34;minimumNumberOfAssignmentsHard&#34;
            ]

            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments[(n)]],
                        [1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )

            if (week_number + 1) == num_weeks:
                model.linear_constraints.add(
                    lin_expr=[cplex.SparsePair([total_assignments[(n)]], [1])],
                    senses=[&#34;G&#34;],
                    rhs=[lower_limit - worked_days_in_previous_weeks],
                )

    def init_ilp_vars_for_soft_constraints(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the variables used for soft constraints to the model.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files

        Returns:
            dic: dictionary that contains the names of introduced variables
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_skills = data[&#34;all_skills&#34;]
        all_days = data[&#34;all_days&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        sc_data = data[&#34;sc_data&#34;]

        # Creates insufficient staffing variables.
        # shifts[(d,s,sk)]: number of nurses under optimal number for day d shift s and skill sk
        vars_to_add = []
        insufficient_staffing = {}
        for d in all_days:
            for s in all_shifts:
                for sk in all_skills:
                    var_name = f&#34;insufficient_staffing_d{d}_s{s}_sk{sk}&#34;
                    vars_to_add.append(var_name)
                    insufficient_staffing[(d, s, sk)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[10] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        # Creates unsatisfied preferences variables.
        # unsatisfied_preferences_n{n}_d{d}_s{s} of nurse n for day d and shift s
        vars_to_add = []
        unsatisfied_preferences = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = f&#34;unsatisfied_preferences_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    unsatisfied_preferences[(n, d, s)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Vars for each nurse n indicationg if how many weekends were they working up to this week over the limit
        vars_to_add = []
        total_working_weekends_over_limit = {}
        for n in all_nurses:
            var_name = f&#34;total_working_weekends_over_limit_n{n}&#34;
            total_working_weekends_over_limit[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[num_weeks] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_assignments_over_limit = {}
        total_assignments_under_limit = {}
        for n in all_nurses:
            var_name1, var_name2 = (
                f&#34;total_assignments_over_limit_n{n}&#34;,
                f&#34;total_assignments_under_limit_n{n}&#34;,
            )
            total_assignments_over_limit[(n)] = var_name1
            total_assignments_under_limit[(n)] = var_name2
            vars_to_add.append(var_name1)
            vars_to_add.append(var_name2)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[7] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_working_days = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;violations_of_max_consecutive_working_days_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                violations_of_max_consecutive_working_days[(n, d)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = (
                        f&#34;violations_of_max_consecutive_working_shifts_n{n}_d{d}_s{s}&#34;
                    )
                    violations_of_max_consecutive_working_shifts[(n, d, s)] = var_name
                    vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_days_off = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;violations_of_max_consecutive_days_off_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                violations_of_max_consecutive_days_off[(n, d)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_days_off = {}
        for n in all_nurses:
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    var_name = f&#34;violations_of_min_consecutive_days_off_n{n}_d{d}_dd{dd}&#34;
                    vars_to_add.append(var_name)
                    violations_of_min_consecutive_days_off[(n, d, dd)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_working_days = {}
        for n in all_nurses:
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    var_name = (
                        f&#34;violations_of_min_consecutive_working_days_n{n}_d{d}_dd{dd}&#34;
                    )
                    vars_to_add.append(var_name)
                    violations_of_min_consecutive_working_days[(n, d, dd)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_working_shifts):
                        var_name = f&#34;violations_of_min_consecutive_working_shifts_n{n}_d{d}_s{s}_dd{dd}&#34;
                        violations_of_min_consecutive_working_shifts[(n, d, s, dd)] = (
                            var_name
                        )
                        vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_assignments_with_if_needed_skill = {}
        for n in all_nurses:
            var_name = f&#34;total_assignments_with_if_needed_skill_n{n}&#34;
            total_assignments_with_if_needed_skill[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[28] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_unsatisfied_overtime = {}
        for n in all_nurses:
            var_name = f&#34;total_unsatisfied_overtime_n{n}&#34;
            total_unsatisfied_overtime[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[7] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        soft_ILP_vars = {}
        soft_ILP_vars[&#34;insufficient_staffing&#34;] = insufficient_staffing
        soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;] = total_unsatisfied_overtime
        soft_ILP_vars[&#34;total_assignments_with_if_needed_skill&#34;] = (
            total_assignments_with_if_needed_skill
        )
        soft_ILP_vars[&#34;unsatisfied_preferences&#34;] = unsatisfied_preferences
        soft_ILP_vars[&#34;total_working_weekends_over_limit&#34;] = (
            total_working_weekends_over_limit
        )
        soft_ILP_vars[&#34;total_assignments_over_limit&#34;] = total_assignments_over_limit
        soft_ILP_vars[&#34;total_assignments_under_limit&#34;] = total_assignments_under_limit
        soft_ILP_vars[&#34;violations_of_max_consecutive_working_days&#34;] = (
            violations_of_max_consecutive_working_days
        )
        soft_ILP_vars[&#34;violations_of_max_consecutive_days_off&#34;] = (
            violations_of_max_consecutive_days_off
        )
        soft_ILP_vars[&#34;violations_of_max_consecutive_working_shifts&#34;] = (
            violations_of_max_consecutive_working_shifts
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_working_days&#34;] = (
            violations_of_min_consecutive_working_days
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_days_off&#34;] = (
            violations_of_min_consecutive_days_off
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_working_shifts&#34;] = (
            violations_of_min_consecutive_working_shifts
        )

        return soft_ILP_vars

    def add_shift_skill_req_optimal_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that introduces the optimal number of assigned nurses for each combination of day, shift, skill.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]

        wd_data = data[&#34;wd_data&#34;]

        for req in wd_data[&#34;requirements&#34;]:
            s = utils.shift_to_int[req[&#34;shiftType&#34;]]
            sk = utils.skill_to_int[req[&#34;skill&#34;]]
            optimal_capacities_in_week = [
                req[&#34;requirementOnMonday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnTuesday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnWednesday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnThursday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnFriday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnSaturday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnSunday&#34;][&#34;optimal&#34;],
            ]

            for d, opt_capacity in enumerate(optimal_capacities_in_week):
                skills_worked = []
                for n in all_nurses:
                    skills_worked.append(shifts_with_skills[n][d][s][sk])
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [insufficient_staffing[(d, s, sk)]] + skills_worked,
                            [1] + [1] * len(skills_worked),
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[opt_capacity],
                )

    def add_insatisfied_preferences_reqs_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that introduces the preferences of nurses for specific assignments/non-assignments.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        wd_data = data[&#34;wd_data&#34;]

        for preference in wd_data[&#34;shiftOffRequests&#34;]:
            nurse_id = int(preference[&#34;nurse&#34;].split(&#34;_&#34;)[1])
            day_id = utils.day_to_int[preference[&#34;day&#34;]]
            shift_id = utils.shift_to_int[preference[&#34;shiftType&#34;]]

            if shift_id != utils.shift_to_int[&#34;Any&#34;]:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                unsatisfied_preferences[(nurse_id, day_id, shift_id)],
                                shifts[nurse_id][day_id][shift_id],
                            ],
                            [1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )
            else:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                unsatisfied_preferences[(nurse_id, day_id, 0)],
                                working_days[nurse_id][day_id],
                            ],
                            [1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_working_weekends_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes more working weekends than the specified maximum.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
        sc_data = data[&#34;sc_data&#34;]
        h0_data = data[&#34;h0_data&#34;]
        total_working_weekends_over_limit = soft_ILP_vars[
            &#34;total_working_weekends_over_limit&#34;
        ]
        working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]

        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair([working_weekends[(n)], working_days[n][5]], [1, -1])
                ],
                senses=[&#34;G&#34;],
                rhs=[0],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair([working_weekends[(n)], working_days[n][6]], [1, -1])
                ],
                senses=[&#34;G&#34;],
                rhs=[0],
            )

        for n in all_nurses:
            worked_weekends_limit_for_this_week = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfWorkingWeekends&#34;] * ((week_number + 1) / num_weeks)
            worked_weekends_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfWorkingWeekends&#34;
            ]
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_working_weekends_over_limit[(n)], working_weekends[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[
                    worked_weekends_limit_for_this_week - worked_weekends_in_previous_weeks
                ],
            )

    def add_incomplete_weekends_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        all_nurses = data[&#34;all_nurses&#34;]

        for n in all_nurses:
            isCompleteWeekendRequested = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;completeWeekends&#34;]
            if isCompleteWeekendRequested == 1:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                incomplete_weekends[(n)],
                                working_weekends[(n)],
                                working_days[n][5],
                                working_days[n][6],
                            ],
                            [-1, 2, -1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_assignments_out_of_bounds_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes total assignments out of bounds specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] &gt; 0):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignments&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;minimumNumberOfAssignments&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_over_limit[(n)], total_assignments[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_under_limit[(n)], total_assignments[(n)]],
                        [1, 1],
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[lower_limit - worked_days_in_previous_weeks],
            )

    def add_max_consecutive_work_days_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive working days over the maximum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_days&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_working_days[(n, d)]]
                                + working_days[n][d - max_consecutive_working_days: d + 1],
                                [-1] + [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_days],
                    )
                else:
                    if (
                        consecutive_working_days_prev_week
                        &gt;= max_consecutive_working_days - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_max_consecutive_working_days[(n, d)]]
                                    + working_days[n][0: d + 1],
                                    [-1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )

    def add_min_consecutive_work_days_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;
        Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_days&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_min_consecutive_working_days[(n, d, dd)]]
                                    + [not_working_days[(n, d)]]
                                    + working_days[n][d - dd: d]
                                    + [not_working_days[(n, d - dd - 1)]],
                                    [-1] + [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_min_consecutive_working_days[
                                                (n, d, dd)
                                            ]
                                        ]
                                        + [not_working_days[(n, d)]]
                                        + working_days[n][0:d],
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;
        Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDaysHard&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [not_working_days[(n, d)]]
                                    + working_days[n][d - dd: d]
                                    + [not_working_days[(n, d - dd - 1)]],
                                    [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == dd - d:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_days[(n, d)]] + working_days[n][0:d],
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_shifts_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_shifts&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

        for n in all_nurses:
            consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;lastAssignedShiftType&#34;
            ]
            lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        if (d - dd) &gt; 0:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_min_consecutive_working_shifts[
                                                (n, d, s, dd)
                                            ]
                                        ]
                                        + [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        )
                                        + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [-1] + [1] * (dd + 2),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd + 1],
                            )
                        else:
                            if (consecutive_working_shifts_prev_week == dd - d) and (
                                lastShittTypeAsInt == s
                            ):
                                model.linear_constraints.add(
                                    lin_expr=[
                                        cplex.SparsePair(
                                            [
                                                violations_of_min_consecutive_working_shifts[
                                                    (n, d, s, dd)
                                                ]
                                            ]
                                            + [not_working_shifts[(n, d, s)]]
                                            + list((shifts[n][ddd][s]) for ddd in range(d)),
                                            [-1] + [1] * (d + 1),
                                        )
                                    ],
                                    senses=[&#34;L&#34;],
                                    rhs=[d],
                                )

    def add_min_consecutive_shifts_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue
            consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;lastAssignedShiftType&#34;
            ]
            lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignmentsHard&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        if (d - dd) &gt; 0:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        )
                                        + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [1] * (dd + 2),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd + 1],
                            )
                        else:
                            if (consecutive_working_shifts_prev_week == dd - d) and (
                                lastShittTypeAsInt == s
                                or consecutive_working_shifts_prev_week == 0
                            ):
                                model.linear_constraints.add(
                                    lin_expr=[
                                        cplex.SparsePair(
                                            [not_working_shifts[(n, d, s)]]
                                            + list((shifts[n][ddd][s]) for ddd in range(d)),
                                            [1] * (d + 1),
                                        )
                                    ],
                                    senses=[&#34;L&#34;],
                                    rhs=[d],
                                )
                        if (d - dd) == 0 and lastShittTypeAsInt != s:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        ),
                                        # + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [1] * (dd + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd],
                            )

    def add_min_consecutive_days_off_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes a number of consecutive days off under the minimum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_min_consecutive_days_off&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                    + [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(d - dd, d)
                                    )
                                    + [working_days[n][d - dd - 1]],
                                    [-1] + [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                        + [working_days[n][d]]
                                        + list(
                                            not_working_days[(n, ddd)]
                                            for ddd in range(0, d)
                                        ),
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraint that bans any number of consecutive days off under the minimum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue
            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOffHard&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(d - dd, d)
                                    )
                                    + [working_days[n][d - dd - 1]],
                                    [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_days_off_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [working_days[n][d]]
                                        + list(
                                            not_working_days[(n, ddd)]
                                            for ddd in range(0, d)
                                        ),
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_work_shifts_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_shifts&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            for s in all_shifts:
                max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;maximumNumberOfConsecutiveAssignments&#34;
                ]
                for d in all_days:
                    if d &gt; max_consecutive_working_shifts:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        violations_of_max_consecutive_working_shifts[
                                            (n, d, s)
                                        ]
                                    ]
                                    + list(
                                        shifts[n][d - dd][s]
                                        for dd in range(1 + max_consecutive_working_shifts)
                                    ),
                                    [-1] + [1] * (max_consecutive_working_shifts + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[max_consecutive_working_shifts],
                        )
                    else:
                        if (last_shift == s) and (
                            consecutive_shifts_prev_week
                            &gt;= max_consecutive_working_shifts - d
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_max_consecutive_working_shifts[
                                                (n, d, s)
                                            ]
                                        ]
                                        + list(shifts[n][dd][s] for dd in range(d + 1)),
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_days_off_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_max_consecutive_days_off&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_days_off[(n, d)]]
                                + working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] + [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )
                else:
                    if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_max_consecutive_days_off[(n, d)]]
                                    + working_days[n][0: d + 1],
                                    [1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;G&#34;],
                            rhs=[1],
                        )

    def add_max_consecutive_work_shifts_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            for s in all_shifts:
                max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;maximumNumberOfConsecutiveAssignmentsHard&#34;
                ]
                for d in all_days:
                    if d &gt; max_consecutive_working_shifts:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    list(
                                        shifts[n][d - dd][s]
                                        for dd in range(1 + max_consecutive_working_shifts)
                                    ),
                                    [1] * (max_consecutive_working_shifts + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[max_consecutive_working_shifts],
                        )
                    else:
                        if (last_shift == s) and (
                            consecutive_shifts_prev_week
                            &gt;= max_consecutive_working_shifts - d
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        list(shifts[n][dd][s] for dd in range(d + 1)),
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive working days over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveWorkingDaysHard&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_days],
                    )
                else:
                    if (
                        consecutive_working_days_prev_week
                        &gt;= max_consecutive_working_days - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )

    def add_max_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveDaysOffHard&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )
                else:
                    if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                            ],
                            senses=[&#34;G&#34;],
                            rhs=[1],
                        )

    def add_total_assignments_with_if_needed_skill_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes any assigment of nurse using a skill that is labeled as &#34;if needed&#34;.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        total_assignments_with_if_needed_skill = soft_ILP_vars[
            &#34;total_assignments_with_if_needed_skill&#34;
        ]

        for n in all_nurses:
            if len(nurses_data[n][&#34;skillsIfNeeded&#34;]) &gt; 0:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [total_assignments_with_if_needed_skill[(n)]]
                            + [
                                shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                                for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                                for s in all_shifts
                                for d in all_days
                            ],
                            [-1]
                            + [1]
                            * len(
                                [
                                    shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                                    for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                                    for s in all_shifts
                                    for d in all_days
                                ]
                            ),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_unsatisfied_overtime_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes unsatisfied wanted overtime per assignment.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_unsatisfied_overtime = soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] == 0):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                (
                    contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                        &#34;maximumNumberOfAssignments&#34;
                    ]
                    + nurses_data[n][&#34;wantedOvertime&#34;]
                )
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = math.ceil(
                (
                    contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                        &#34;maximumNumberOfAssignments&#34;
                    ]
                    + nurses_data[n][&#34;wantedOvertime&#34;]
                )
                * ((week_number + 1) / num_weeks)
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_over_limit[(n)], total_assignments[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_unsatisfied_overtime[(n)], total_assignments[(n)]],
                        [1, 1],
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[lower_limit - worked_days_in_previous_weeks],
            )

    def add_soft_constraints(self, model, basic_ILP_vars, soft_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraints to the model.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        if data[&#34;configuration&#34;][&#34;s1&#34;]:
            self.add_shift_skill_req_optimal_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s2&#34;]:
            self.add_min_consecutive_shifts_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_max_consecutive_work_days_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_max_consecutive_work_shifts_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_min_consecutive_work_days_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s3&#34;]:
            self.add_max_consecutive_days_off_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_min_consecutive_days_off_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s4&#34;]:
            self.add_insatisfied_preferences_reqs_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s6&#34;]:
            self.add_total_assignments_out_of_bounds_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s7&#34;]:
            self.add_total_working_weekends_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s8&#34;]:
            self.add_total_assignments_with_if_needed_skill_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s9&#34;]:
            self.add_total_unsatisfied_overtime_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        # add_incomplete_weekends_constraint_soft(self, model, basic_ILP_vars, soft_ILP_vars, data)

    def save_tmp_results(self, results, sol, data, basic_ILP_vars, soft_ILP_vars):
        &#34;&#34;&#34;Stores the solution into the results dictionary.

        Args:
            results (dict): dictionary used to store partially computed schedule
            sol (_type_): _description_
            data (dict): dictionary that contains data from input files
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
        &#34;&#34;&#34;
        num_days = data[&#34;num_days&#34;]
        num_nurses = data[&#34;num_nurses&#34;]
        num_skills = data[&#34;num_skills&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        if not sol.is_primal_feasible():
            return

        results[(week_number, &#34;status&#34;)] = utils.STATUS_OK
        print(&#34;obj. value: &#34; + str(sol.get_objective_value()))

        for n in range(num_nurses):
            for d in range(num_days):
                for s in range(num_shifts):
                    for sk in range(num_skills):
                        results[(n, d + 7 * week_number, s, sk)] = round(
                            sol.get_values(shifts_with_skills[n][d][s][sk])
                        )

    def set_objective_function(self, model, data, basic_ILP_vars, soft_ILP_vars):
        &#34;&#34;&#34;Sets the objective function contatining all penalties from all enabled constraints.

        Args:
            model : object that represents the mathematical model
            data (dict): dictionary that contains data from input files
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_skills = data[&#34;all_skills&#34;]
        all_days = data[&#34;all_days&#34;]

        sc_data = data[&#34;sc_data&#34;]

        num_nurses = data[&#34;num_nurses&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        num_skills = data[&#34;num_skills&#34;]
        num_days = data[&#34;num_days&#34;]

        insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]
        unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
        total_working_weekends_over_limit = soft_ILP_vars[
            &#34;total_working_weekends_over_limit&#34;
        ]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
        violations_of_max_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_days&#34;
        ]
        violations_of_max_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_shifts&#34;
        ]
        violations_of_max_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_max_consecutive_days_off&#34;
        ]
        violations_of_min_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_days&#34;
        ]
        violations_of_min_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_min_consecutive_days_off&#34;
        ]
        violations_of_min_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_shifts&#34;
        ]
        total_assignments_with_if_needed_skill = soft_ILP_vars[
            &#34;total_assignments_with_if_needed_skill&#34;
        ]

        model.objective.set_sense(model.objective.sense.minimize)

        summed_violations_of_min_cons_working_days = []
        weights_of_violations_of_min_cons_working_days = []
        for n in all_nurses:
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    summed_violations_of_min_cons_working_days.append(
                        violations_of_min_consecutive_working_days[(n, d, dd)]
                    )
                    weights_of_violations_of_min_cons_working_days.append(30 * dd)

        summed_violations_of_min_cons_days_off = []
        weights_of_violations_of_min_cons_days_off = []
        for n in all_nurses:
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    summed_violations_of_min_cons_days_off.append(
                        violations_of_min_consecutive_days_off[(n, d, dd)]
                    )
                    weights_of_violations_of_min_cons_days_off.append(30 * dd)

        summed_violations_of_min_cons_shift_type = []
        weights_of_violations_of_min_cons_shift_type = []
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        summed_violations_of_min_cons_shift_type.append(
                            violations_of_min_consecutive_working_shifts[(n, d, s, dd)]
                        )
                        weights_of_violations_of_min_cons_shift_type.append(15 * dd)

        model.objective.set_linear(
            list(
                itertools.chain.from_iterable(
                    [
                        zip(
                            (
                                insufficient_staffing[(d, s, sk)]
                                for d in all_days
                                for s in all_shifts
                                for sk in all_skills
                            ),
                            [30] * num_days * num_shifts * num_skills,
                        ),
                        zip(
                            (
                                unsatisfied_preferences[(n, d, s)]
                                for n in all_nurses
                                for d in all_days
                                for s in all_shifts
                            ),
                            [10] * num_nurses * num_days * num_shifts,
                        ),
                        zip(
                            (total_working_weekends_over_limit[(n)] for n in all_nurses),
                            [30] * num_nurses,
                        ),
                        zip(
                            (incomplete_weekends[(n)] for n in all_nurses),
                            [30] * num_nurses,
                        ),
                        zip(
                            (total_assignments_over_limit[(n)] for n in all_nurses),
                            [20] * num_nurses,
                        ),
                        zip(
                            (total_assignments_under_limit[(n)] for n in all_nurses),
                            [20] * num_nurses,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_working_days[(n, d)]
                                for n in all_nurses
                                for d in all_days
                            ),
                            [30] * num_nurses * num_days,
                        ),
                        zip(
                            summed_violations_of_min_cons_working_days,
                            weights_of_violations_of_min_cons_working_days,
                        ),
                        zip(
                            summed_violations_of_min_cons_days_off,
                            weights_of_violations_of_min_cons_days_off,
                        ),
                        zip(
                            summed_violations_of_min_cons_shift_type,
                            weights_of_violations_of_min_cons_shift_type,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_days_off[(n, d)]
                                for n in all_nurses
                                for d in all_days
                            ),
                            [30] * num_nurses * num_days,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_working_shifts[(n, d, s)]
                                for n in all_nurses
                                for d in all_days
                                for s in all_shifts
                            ),
                            [15] * num_nurses * num_days * num_shifts,
                        ),
                        zip(
                            (
                                total_assignments_with_if_needed_skill[(n)]
                                for n in all_nurses
                            ),
                            [15] * num_nurses,
                        ),
                    ]
                )
            )
        )

        return

    def setup_problem(self, model, data, results):
        &#34;&#34;&#34;Sets up the mathematical model to be solved.

        Args:
            model : object that represents the mathematical model
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule

        Returns:
            (dict, dict): 2 dictionaries that contains names of variables of the mathematical model
        &#34;&#34;&#34;
        self.prepare_help_data(data, results)

        # Create ILP variables.
        basic_ILP_vars = self.init_ilp_vars(model, data)

        # Add hard constrains to model
        self.add_hard_constrains(model, basic_ILP_vars, data)

        # soft_ILP_vars = {}
        soft_ILP_vars = self.init_ilp_vars_for_soft_constraints(model, basic_ILP_vars, data)

        self.add_soft_constraints(model, basic_ILP_vars, soft_ILP_vars, data)

        self.set_objective_function(model, data, basic_ILP_vars, soft_ILP_vars)

        return basic_ILP_vars, soft_ILP_vars

    def compute_one_week(self, time_limit_for_week, data, results):
        &#34;&#34;&#34;Computes a schedule for a week given a time limit and data.

        Args:
            time_limit_for_week (int): time limit for finding a schedule as optimal as possible
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule
        &#34;&#34;&#34;
        model = cplex.Cplex()
        model.parameters.mip.display.set(0)
        model.parameters.output.clonelog.set(0)
        # c.set_log_stream(&#34;log.txt&#34;)
        model.parameters.simplex.display.set(0)
        model.parameters.threads.set(1)
        model.parameters.timelimit.set(time_limit_for_week)
        model.parameters.mip.tolerances.absmipgap.set(0.0)
        model.parameters.emphasis.mip.set(model.parameters.emphasis.mip.values.optimality)

        basic_ILP_vars, soft_ILP_vars = self.setup_problem(model, data, results)

        model.solve()
        sol = model.solution
        print(sol.get_method())
        print(f&#34;number of threads: {model.parameters.threads.get()}&#34;)

        self.save_tmp_results(results, sol, data, basic_ILP_vars, soft_ILP_vars)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver"><code class="flex name class">
<span>class <span class="ident">CplexSolver</span></span>
</code></dt>
<dd>
<div class="desc"><p>Child Class from NSP_solver that uses MILP cplex solver via API to compute a schedule per week.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CplexSolver(NSP_solver):
    &#34;&#34;&#34;Child Class from NSP_solver that uses MILP cplex solver via API to compute a schedule per week.
    &#34;&#34;&#34;
    name = &#39;CPLEX&#39;

    def prepare_help_data(self, data, results):
        &#34;&#34;&#34;Prepares helpful data for other methods.

        Args:
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule
        &#34;&#34;&#34;
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;] = list(
            map(lambda x: int(x.split(&#34;_&#34;)[1]), data[&#34;wd_data&#34;][&#34;vacations&#34;])
        )

        results[(week_number, &#34;status&#34;)] = utils.STATUS_FAIL

    def init_ilp_vars(self, model, data):
        &#34;&#34;&#34;
        Initializes basic variables for primarly for hard contraints.

        Args:
            model: object that represents the mathematical model
            data (dict): dictionary that contains data from input files

        Returns:
            dict: dictionary &#39;basic_ILP_vars&#39; that contains the names variables of the mathematical model
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        all_skills = data[&#34;all_skills&#34;]
        num_days = data[&#34;num_days&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

        # Creates shifts variables.
        # shifts[n][d][s]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; if 1 does not work if 0.
        vars_to_add = []
        shifts = []
        for n in all_nurses:
            shifts.append([])
            for d in all_days:
                shifts[n].append([])
                for s in all_shifts:
                    var_name = f&#34;shift_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    shifts[n][d].append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Creates working_days variables.
        # shifts[n][d][s]: nurse &#39;n&#39; works on day &#39;d&#39; if 1 does not work if 0.
        vars_to_add = []
        working_days = []
        for n in all_nurses:
            working_days.append([])
            for d in all_days:
                var_name = f&#34;work_day_n{n}_d{d}&#34;
                working_days[n].append(var_name)
                vars_to_add.append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Creates shifts_with_skills variables.
        # shifts_with_skills[(n, d, s, sk)]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; with skill &#39;sk&#39;.
        vars_to_add = []
        shifts_with_skills = []
        for n in all_nurses:
            shifts_with_skills.append([])
            for d in all_days:
                shifts_with_skills[n].append([])
                for s in all_shifts:
                    shifts_with_skills[n][d].append([])
                    for sk in all_skills:
                        var_name = f&#34;shift_with_skill_n{n}_d{d}_s{s}_sk{sk}&#34;
                        vars_to_add.append(var_name)
                        shifts_with_skills[n][d][s].append(var_name)

        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        not_working_days = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;not_working_day_n{n}_d{d}&#34;
                not_working_days[(n, d)] = var_name
                vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [not_working_days[(n, d)], working_days[n][d]], [1, 1]
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[1],
                )

        vars_to_add = []
        not_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = f&#34;not_workingshift_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    not_working_shifts[(n, d, s)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [not_working_shifts[(n, d, s)], shifts[n][d][s]], [1, 1]
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[1],
                    )

        # Vars for each nurse how many days they worked
        vars_to_add = []
        total_assignments = {}
        for n in all_nurses:
            var_name = f&#34;total_assignments_n{n}&#34;
            total_assignments[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[num_days + 1] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments[(n)]]
                        + [shifts[n][d][s] for d in all_days for s in all_shifts],
                        [-1]
                        + [1]
                        * len([shifts[n][d][s] for d in all_days for s in all_shifts]),
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

        # Vars for each nurse n indicationg if they were working on weekend this week
        vars_to_add = []
        working_weekends = {}
        for n in all_nurses:
            var_name = f&#34;working_weekends_n{n}&#34;
            working_weekends[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        incomplete_weekends = {}
        for n in all_nurses:
            var_name = f&#34;incomplete_weekends_n{n}&#34;
            vars_to_add.append(var_name)
            incomplete_weekends[(n)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        for n in all_nurses:
            isCompleteWeekendRequested = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;completeWeekends&#34;]
            if isCompleteWeekendRequested == 1:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                incomplete_weekends[(n)],
                                working_weekends[(n)],
                                working_days[n][5],
                                working_days[n][6],
                            ],
                            [-1, 2, -1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

        basic_ILP_vars = {}
        basic_ILP_vars[&#34;working_days&#34;] = working_days
        basic_ILP_vars[&#34;incomplete_weekends&#34;] = incomplete_weekends
        basic_ILP_vars[&#34;total_assignments&#34;] = total_assignments
        basic_ILP_vars[&#34;working_weekends&#34;] = working_weekends
        basic_ILP_vars[&#34;not_working_days&#34;] = not_working_days
        basic_ILP_vars[&#34;not_working_shifts&#34;] = not_working_shifts
        basic_ILP_vars[&#34;shifts&#34;] = shifts
        basic_ILP_vars[&#34;shifts_with_skills&#34;] = shifts_with_skills
        return basic_ILP_vars

    def add_shift_succession_reqs(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;
        Adds hard constraint that disables invalid pairs of succcessive shift types.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        num_days = data[&#34;num_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            if last_shift == 2:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][0][last_shift - 1], shifts[n][0][last_shift - 2]],
                            [1] * 2,
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )
            if last_shift == 3:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                shifts[n][0][last_shift - 1],
                                shifts[n][0][last_shift - 2],
                                shifts[n][0][last_shift - 3],
                            ],
                            [1] * 3,
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

            for d in range(num_days - 1):
                for s in all_shifts:
                    if s == 2:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        shifts[n][d][s],
                                        shifts[n][d + 1][s - 1],
                                        shifts[n][d + 1][s - 2],
                                    ],
                                    [1] * 3,
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[1],
                        )
                    if s == 3:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        shifts[n][d][s],
                                        shifts[n][d + 1][s - 1],
                                        shifts[n][d + 1][s - 2],
                                        shifts[n][d + 1][s - 3],
                                    ],
                                    [1] * 4,
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[1],
                        )

    def add_missing_skill_req(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds hard constraint that disables nurses working shift with a skill that they do not possess.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        all_skills = data[&#34;all_skills&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

        for n, nurse_data in enumerate(nurses_data):
            for sk in all_skills:
                has_skill = False
                for skill in nurse_data[&#34;skills&#34;]:
                    if sk == utils.skill_to_int[skill]:
                        has_skill = True
                        break
                if has_skill is False:
                    for d in all_days:
                        for s in all_shifts:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair([shifts_with_skills[n][d][s][sk]], [1])
                                ],
                                senses=[&#34;E&#34;],
                                rhs=[0],
                            )

    def add_hard_constrains(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds all hard constraints to the model.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        if data[&#34;configuration&#34;][&#34;h1&#34;]:
            self.add_max_one_shift_per_day_constraint(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h2&#34;]:
            self.add_shift_skill_req_minimal(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h3&#34;]:
            self.add_shift_succession_reqs(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h4&#34;]:
            self.add_missing_skill_req(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h5&#34;]:
            self.add_max_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
            self.add_max_consecutive_work_shifts_constraint_hard(
                model, basic_ILP_vars, data
            )
            self.add_min_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
            self.add_min_consecutive_shifts_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h6&#34;]:
            self.add_max_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)
            self.add_min_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h7&#34;]:
            self.add_max_incomplete_weekends_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h8&#34;]:
            self.add_max_min_total_assignments_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h9&#34;]:
            self.add_min_continuous_free_period_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h10&#34;]:
            self.add_max_one_shift_per_day_exception_constraint_hard(
                model, basic_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;h11&#34;]:
            self.add_max_shift_of_given_type_constraint_hard(model, basic_ILP_vars, data)

        if data[&#34;configuration&#34;][&#34;h12&#34;]:
            self.add_vacations_reqs_constraint_hard(model, basic_ILP_vars, data)

    def add_max_incomplete_weekends_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

        for n in all_nurses:
            incomplete_weekends_prev = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfIncompleteWeekends&#34;
            ]
            max_incomplete_weekends = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfIncompleteWeekendsHard&#34;]
            model.linear_constraints.add(
                lin_expr=[cplex.SparsePair([incomplete_weekends[(n)]], [1])],
                senses=[&#34;L&#34;],
                rhs=[max_incomplete_weekends - incomplete_weekends_prev],
            )

    def add_max_one_shift_per_day_constraint(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        # Each nurse works at most one shift per day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(shifts[n][d][:], [1] * len(shifts[n][d][:]))
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

        # Each nurse works at most one skill per shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                shifts_with_skills[n][d][s][:],
                                [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

        # If nurse is working with skill that shift, she is working that shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                                [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[0],
                    )

        # If nurse is working with a shift, she is working that day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [-1] + [1] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_max_shift_of_given_type_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that disallows more assignments to a specific shift type than it is allowed.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        num_days = data[&#34;num_days&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            already_assigned = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numbersOfAssignedRestrictedShiftTypes&#34;
            ]
            for restriction in data[&#34;sc_data&#34;][&#34;nurses&#34;][n][&#34;restrictions&#34;]:
                shift_id = utils.shift_to_int[restriction[&#34;type&#34;]]
                limit = restriction[&#34;limit&#34;]
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][d][shift_id] for d in all_days], [1] * num_days
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[limit - already_assigned[shift_id][&#34;numberOfAssignments&#34;]],
                )

    def add_max_one_shift_per_day_exception_constraint_hard(
        self, model, basic_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day with the exception of early and night shifts on the same day.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_days = data[&#34;all_days&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        # Each nurse works at most one shift per day with an exception early + night.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            shifts[n][d][0: (num_shifts - 1)], [1] * (num_shifts - 1)
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(shifts[n][d][1:num_shifts], [1] * (num_shifts - 1))
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

        # If nurse is working with a shift, she is working that day.
        for n in all_nurses:
            for d in all_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [-4] + [1] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[0],
                )
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [working_days[n][d]] + shifts[n][d][:],
                            [1] + [-2] * len(shifts[n][d][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[0],
                )

        # Each nurse works at most one skill per shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                shifts_with_skills[n][d][s][:],
                                [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

        # If nurse is working with skill that shift, she is working that shift.
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                                [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                            )
                        ],
                        senses=[&#34;E&#34;],
                        rhs=[0],
                    )

    def add_vacations_reqs_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignments fot a nurse that is has planned a vacation.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        wd_data = data[&#34;wd_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for nurse_id in wd_data[&#34;vacations_with_ids&#34;]:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        working_days[nurse_id][:], [1] * len(working_days[nurse_id][:])
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

    def add_shift_skill_req_minimal(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds hard constraint that dictates minimal number of nurses in a shift working with specific skill.

        Args:
            model (_type_): _description_
            basic_ILP_vars (_type_): _description_
            data (_type_): _description_
        &#34;&#34;&#34;

        all_nurses = data[&#34;all_nurses&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        for req in data[&#34;wd_data&#34;][&#34;requirements&#34;]:

            s = utils.shift_to_int[req[&#34;shiftType&#34;]]
            sk = utils.skill_to_int[req[&#34;skill&#34;]]
            minimal_capacities_in_week = [
                req[&#34;requirementOnMonday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnTuesday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnWednesday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnThursday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnFriday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnSaturday&#34;][&#34;minimum&#34;],
                req[&#34;requirementOnSunday&#34;][&#34;minimum&#34;],
            ]

            for d, min_capacity in enumerate(minimal_capacities_in_week):
                skills_worked = []
                for n in all_nurses:
                    skills_worked.append(shifts_with_skills[n][d][s][sk])
                model.linear_constraints.add(
                    lin_expr=[cplex.SparsePair(skills_worked, [1] * len(skills_worked))],
                    senses=[&#34;G&#34;],
                    rhs=[min_capacity],
                )

    def add_min_continuous_free_period_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that enforces that every nurse has a minimal continuous period of days off.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        num_days = data[&#34;num_days&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
            contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
            min_free_period = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;minimalFreePeriod&#34;]

            vars_to_add = []
            free_periods = {}
            for d in range(num_days - min_free_period + 1):
                var_name = f&#34;free_period_of_{min_free_period}_days_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                free_periods[(n, d)] = var_name
            model.variables.add(
                names=vars_to_add,
                lb=[0] * len(vars_to_add),
                ub=[1] * len(vars_to_add),
                types=[&#34;N&#34;] * len(vars_to_add),
            )

            for d in range(num_days - min_free_period + 1):
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [free_periods[(n, d)]]
                            + working_days[n][d: d + min_free_period],
                            [1] + [1] * min_free_period,
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[0],
                )

                for dd in range(d, d + min_free_period):
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [free_periods[(n, d)]] + [working_days[n][dd]],
                                [1] + [1],
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )

            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            free_periods[(n, d)]
                            for d in range(num_days - min_free_period + 1)
                        ],
                        [1] * (num_days - min_free_period + 1),
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[1],
            )

    def add_max_min_total_assignments_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that enforces that total number of assignemnts a nurse are in the limits specified in the contract of the nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignmentsHard&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                &#34;minimumNumberOfAssignmentsHard&#34;
            ]

            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments[(n)]],
                        [1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )

            if (week_number + 1) == num_weeks:
                model.linear_constraints.add(
                    lin_expr=[cplex.SparsePair([total_assignments[(n)]], [1])],
                    senses=[&#34;G&#34;],
                    rhs=[lower_limit - worked_days_in_previous_weeks],
                )

    def init_ilp_vars_for_soft_constraints(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the variables used for soft constraints to the model.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files

        Returns:
            dic: dictionary that contains the names of introduced variables
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_skills = data[&#34;all_skills&#34;]
        all_days = data[&#34;all_days&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        sc_data = data[&#34;sc_data&#34;]

        # Creates insufficient staffing variables.
        # shifts[(d,s,sk)]: number of nurses under optimal number for day d shift s and skill sk
        vars_to_add = []
        insufficient_staffing = {}
        for d in all_days:
            for s in all_shifts:
                for sk in all_skills:
                    var_name = f&#34;insufficient_staffing_d{d}_s{s}_sk{sk}&#34;
                    vars_to_add.append(var_name)
                    insufficient_staffing[(d, s, sk)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[10] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        # Creates unsatisfied preferences variables.
        # unsatisfied_preferences_n{n}_d{d}_s{s} of nurse n for day d and shift s
        vars_to_add = []
        unsatisfied_preferences = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = f&#34;unsatisfied_preferences_n{n}_d{d}_s{s}&#34;
                    vars_to_add.append(var_name)
                    unsatisfied_preferences[(n, d, s)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        # Vars for each nurse n indicationg if how many weekends were they working up to this week over the limit
        vars_to_add = []
        total_working_weekends_over_limit = {}
        for n in all_nurses:
            var_name = f&#34;total_working_weekends_over_limit_n{n}&#34;
            total_working_weekends_over_limit[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[num_weeks] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_assignments_over_limit = {}
        total_assignments_under_limit = {}
        for n in all_nurses:
            var_name1, var_name2 = (
                f&#34;total_assignments_over_limit_n{n}&#34;,
                f&#34;total_assignments_under_limit_n{n}&#34;,
            )
            total_assignments_over_limit[(n)] = var_name1
            total_assignments_under_limit[(n)] = var_name2
            vars_to_add.append(var_name1)
            vars_to_add.append(var_name2)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[7] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_working_days = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;violations_of_max_consecutive_working_days_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                violations_of_max_consecutive_working_days[(n, d)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    var_name = (
                        f&#34;violations_of_max_consecutive_working_shifts_n{n}_d{d}_s{s}&#34;
                    )
                    violations_of_max_consecutive_working_shifts[(n, d, s)] = var_name
                    vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_max_consecutive_days_off = {}
        for n in all_nurses:
            for d in all_days:
                var_name = f&#34;violations_of_max_consecutive_days_off_n{n}_d{d}&#34;
                vars_to_add.append(var_name)
                violations_of_max_consecutive_days_off[(n, d)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_days_off = {}
        for n in all_nurses:
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    var_name = f&#34;violations_of_min_consecutive_days_off_n{n}_d{d}_dd{dd}&#34;
                    vars_to_add.append(var_name)
                    violations_of_min_consecutive_days_off[(n, d, dd)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_working_days = {}
        for n in all_nurses:
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    var_name = (
                        f&#34;violations_of_min_consecutive_working_days_n{n}_d{d}_dd{dd}&#34;
                    )
                    vars_to_add.append(var_name)
                    violations_of_min_consecutive_working_days[(n, d, dd)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        violations_of_min_consecutive_working_shifts = {}
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_working_shifts):
                        var_name = f&#34;violations_of_min_consecutive_working_shifts_n{n}_d{d}_s{s}_dd{dd}&#34;
                        violations_of_min_consecutive_working_shifts[(n, d, s, dd)] = (
                            var_name
                        )
                        vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;B&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_assignments_with_if_needed_skill = {}
        for n in all_nurses:
            var_name = f&#34;total_assignments_with_if_needed_skill_n{n}&#34;
            total_assignments_with_if_needed_skill[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[28] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        vars_to_add = []
        total_unsatisfied_overtime = {}
        for n in all_nurses:
            var_name = f&#34;total_unsatisfied_overtime_n{n}&#34;
            total_unsatisfied_overtime[(n)] = var_name
            vars_to_add.append(var_name)
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[7] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        soft_ILP_vars = {}
        soft_ILP_vars[&#34;insufficient_staffing&#34;] = insufficient_staffing
        soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;] = total_unsatisfied_overtime
        soft_ILP_vars[&#34;total_assignments_with_if_needed_skill&#34;] = (
            total_assignments_with_if_needed_skill
        )
        soft_ILP_vars[&#34;unsatisfied_preferences&#34;] = unsatisfied_preferences
        soft_ILP_vars[&#34;total_working_weekends_over_limit&#34;] = (
            total_working_weekends_over_limit
        )
        soft_ILP_vars[&#34;total_assignments_over_limit&#34;] = total_assignments_over_limit
        soft_ILP_vars[&#34;total_assignments_under_limit&#34;] = total_assignments_under_limit
        soft_ILP_vars[&#34;violations_of_max_consecutive_working_days&#34;] = (
            violations_of_max_consecutive_working_days
        )
        soft_ILP_vars[&#34;violations_of_max_consecutive_days_off&#34;] = (
            violations_of_max_consecutive_days_off
        )
        soft_ILP_vars[&#34;violations_of_max_consecutive_working_shifts&#34;] = (
            violations_of_max_consecutive_working_shifts
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_working_days&#34;] = (
            violations_of_min_consecutive_working_days
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_days_off&#34;] = (
            violations_of_min_consecutive_days_off
        )
        soft_ILP_vars[&#34;violations_of_min_consecutive_working_shifts&#34;] = (
            violations_of_min_consecutive_working_shifts
        )

        return soft_ILP_vars

    def add_shift_skill_req_optimal_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that introduces the optimal number of assigned nurses for each combination of day, shift, skill.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]

        wd_data = data[&#34;wd_data&#34;]

        for req in wd_data[&#34;requirements&#34;]:
            s = utils.shift_to_int[req[&#34;shiftType&#34;]]
            sk = utils.skill_to_int[req[&#34;skill&#34;]]
            optimal_capacities_in_week = [
                req[&#34;requirementOnMonday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnTuesday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnWednesday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnThursday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnFriday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnSaturday&#34;][&#34;optimal&#34;],
                req[&#34;requirementOnSunday&#34;][&#34;optimal&#34;],
            ]

            for d, opt_capacity in enumerate(optimal_capacities_in_week):
                skills_worked = []
                for n in all_nurses:
                    skills_worked.append(shifts_with_skills[n][d][s][sk])
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [insufficient_staffing[(d, s, sk)]] + skills_worked,
                            [1] + [1] * len(skills_worked),
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[opt_capacity],
                )

    def add_insatisfied_preferences_reqs_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that introduces the preferences of nurses for specific assignments/non-assignments.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        wd_data = data[&#34;wd_data&#34;]

        for preference in wd_data[&#34;shiftOffRequests&#34;]:
            nurse_id = int(preference[&#34;nurse&#34;].split(&#34;_&#34;)[1])
            day_id = utils.day_to_int[preference[&#34;day&#34;]]
            shift_id = utils.shift_to_int[preference[&#34;shiftType&#34;]]

            if shift_id != utils.shift_to_int[&#34;Any&#34;]:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                unsatisfied_preferences[(nurse_id, day_id, shift_id)],
                                shifts[nurse_id][day_id][shift_id],
                            ],
                            [1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )
            else:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                unsatisfied_preferences[(nurse_id, day_id, 0)],
                                working_days[nurse_id][day_id],
                            ],
                            [1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_working_weekends_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes more working weekends than the specified maximum.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
        sc_data = data[&#34;sc_data&#34;]
        h0_data = data[&#34;h0_data&#34;]
        total_working_weekends_over_limit = soft_ILP_vars[
            &#34;total_working_weekends_over_limit&#34;
        ]
        working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]

        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair([working_weekends[(n)], working_days[n][5]], [1, -1])
                ],
                senses=[&#34;G&#34;],
                rhs=[0],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair([working_weekends[(n)], working_days[n][6]], [1, -1])
                ],
                senses=[&#34;G&#34;],
                rhs=[0],
            )

        for n in all_nurses:
            worked_weekends_limit_for_this_week = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfWorkingWeekends&#34;] * ((week_number + 1) / num_weeks)
            worked_weekends_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfWorkingWeekends&#34;
            ]
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_working_weekends_over_limit[(n)], working_weekends[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[
                    worked_weekends_limit_for_this_week - worked_weekends_in_previous_weeks
                ],
            )

    def add_incomplete_weekends_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        all_nurses = data[&#34;all_nurses&#34;]

        for n in all_nurses:
            isCompleteWeekendRequested = contracts_data[
                utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
            ][&#34;completeWeekends&#34;]
            if isCompleteWeekendRequested == 1:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [
                                incomplete_weekends[(n)],
                                working_weekends[(n)],
                                working_days[n][5],
                                working_days[n][6],
                            ],
                            [-1, 2, -1, -1],
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_assignments_out_of_bounds_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes total assignments out of bounds specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] &gt; 0):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignments&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = math.ceil(
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;minimumNumberOfAssignments&#34;
                ]
                * ((week_number + 1) / num_weeks)
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_over_limit[(n)], total_assignments[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_under_limit[(n)], total_assignments[(n)]],
                        [1, 1],
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[lower_limit - worked_days_in_previous_weeks],
            )

    def add_max_consecutive_work_days_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive working days over the maximum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_days&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_working_days[(n, d)]]
                                + working_days[n][d - max_consecutive_working_days: d + 1],
                                [-1] + [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_days],
                    )
                else:
                    if (
                        consecutive_working_days_prev_week
                        &gt;= max_consecutive_working_days - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_max_consecutive_working_days[(n, d)]]
                                    + working_days[n][0: d + 1],
                                    [-1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )

    def add_min_consecutive_work_days_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;
        Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_days&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_min_consecutive_working_days[(n, d, dd)]]
                                    + [not_working_days[(n, d)]]
                                    + working_days[n][d - dd: d]
                                    + [not_working_days[(n, d - dd - 1)]],
                                    [-1] + [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_min_consecutive_working_days[
                                                (n, d, dd)
                                            ]
                                        ]
                                        + [not_working_days[(n, d)]]
                                        + working_days[n][0:d],
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;
        Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDaysHard&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [not_working_days[(n, d)]]
                                    + working_days[n][d - dd: d]
                                    + [not_working_days[(n, d - dd - 1)]],
                                    [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == dd - d:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_days[(n, d)]] + working_days[n][0:d],
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_shifts_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_shifts&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

        for n in all_nurses:
            consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;lastAssignedShiftType&#34;
            ]
            lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        if (d - dd) &gt; 0:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_min_consecutive_working_shifts[
                                                (n, d, s, dd)
                                            ]
                                        ]
                                        + [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        )
                                        + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [-1] + [1] * (dd + 2),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd + 1],
                            )
                        else:
                            if (consecutive_working_shifts_prev_week == dd - d) and (
                                lastShittTypeAsInt == s
                            ):
                                model.linear_constraints.add(
                                    lin_expr=[
                                        cplex.SparsePair(
                                            [
                                                violations_of_min_consecutive_working_shifts[
                                                    (n, d, s, dd)
                                                ]
                                            ]
                                            + [not_working_shifts[(n, d, s)]]
                                            + list((shifts[n][ddd][s]) for ddd in range(d)),
                                            [-1] + [1] * (d + 1),
                                        )
                                    ],
                                    senses=[&#34;L&#34;],
                                    rhs=[d],
                                )

    def add_min_consecutive_shifts_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]
        not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue
            consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;lastAssignedShiftType&#34;
            ]
            lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignmentsHard&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        if (d - dd) &gt; 0:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        )
                                        + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [1] * (dd + 2),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd + 1],
                            )
                        else:
                            if (consecutive_working_shifts_prev_week == dd - d) and (
                                lastShittTypeAsInt == s
                                or consecutive_working_shifts_prev_week == 0
                            ):
                                model.linear_constraints.add(
                                    lin_expr=[
                                        cplex.SparsePair(
                                            [not_working_shifts[(n, d, s)]]
                                            + list((shifts[n][ddd][s]) for ddd in range(d)),
                                            [1] * (d + 1),
                                        )
                                    ],
                                    senses=[&#34;L&#34;],
                                    rhs=[d],
                                )
                        if (d - dd) == 0 and lastShittTypeAsInt != s:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_shifts[(n, d, s)]]
                                        + list(
                                            (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                        ),
                                        # + [not_working_shifts[(n, d - dd - 1, s)]],
                                        [1] * (dd + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[dd],
                            )

    def add_min_consecutive_days_off_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes a number of consecutive days off under the minimum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_min_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_min_consecutive_days_off&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                    + [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(d - dd, d)
                                    )
                                    + [working_days[n][d - dd - 1]],
                                    [-1] + [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_working_days_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                        + [working_days[n][d]]
                                        + list(
                                            not_working_days[(n, ddd)]
                                            for ddd in range(0, d)
                                        ),
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_min_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraint that bans any number of consecutive days off under the minimum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]
        not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue
            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOffHard&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(d - dd, d)
                                    )
                                    + [working_days[n][d - dd - 1]],
                                    [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if consecutive_days_off_prev_week == d - dd:
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [working_days[n][d]]
                                        + list(
                                            not_working_days[(n, ddd)]
                                            for ddd in range(0, d)
                                        ),
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_work_shifts_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_shifts&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            for s in all_shifts:
                max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;maximumNumberOfConsecutiveAssignments&#34;
                ]
                for d in all_days:
                    if d &gt; max_consecutive_working_shifts:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        violations_of_max_consecutive_working_shifts[
                                            (n, d, s)
                                        ]
                                    ]
                                    + list(
                                        shifts[n][d - dd][s]
                                        for dd in range(1 + max_consecutive_working_shifts)
                                    ),
                                    [-1] + [1] * (max_consecutive_working_shifts + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[max_consecutive_working_shifts],
                        )
                    else:
                        if (last_shift == s) and (
                            consecutive_shifts_prev_week
                            &gt;= max_consecutive_working_shifts - d
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_max_consecutive_working_shifts[
                                                (n, d, s)
                                            ]
                                        ]
                                        + list(shifts[n][dd][s] for dd in range(d + 1)),
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_days_off_constraint_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        violations_of_max_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_max_consecutive_days_off&#34;
        ]
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_days_off[(n, d)]]
                                + working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] + [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )
                else:
                    if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_max_consecutive_days_off[(n, d)]]
                                    + working_days[n][0: d + 1],
                                    [1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;G&#34;],
                            rhs=[1],
                        )

    def add_max_consecutive_work_shifts_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        sc_data = data[&#34;sc_data&#34;]
        shifts = basic_ILP_vars[&#34;shifts&#34;]

        for n in all_nurses:
            last_shift = utils.shift_to_int[
                data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
            ]
            consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveAssignments&#34;
            ]
            for s in all_shifts:
                max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;maximumNumberOfConsecutiveAssignmentsHard&#34;
                ]
                for d in all_days:
                    if d &gt; max_consecutive_working_shifts:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    list(
                                        shifts[n][d - dd][s]
                                        for dd in range(1 + max_consecutive_working_shifts)
                                    ),
                                    [1] * (max_consecutive_working_shifts + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[max_consecutive_working_shifts],
                        )
                    else:
                        if (last_shift == s) and (
                            consecutive_shifts_prev_week
                            &gt;= max_consecutive_working_shifts - d
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        list(shifts[n][dd][s] for dd in range(d + 1)),
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )

    def add_max_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive working days over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveWorkingDays&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveWorkingDaysHard&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_days],
                    )
                else:
                    if (
                        consecutive_working_days_prev_week
                        &gt;= max_consecutive_working_days - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )

    def add_max_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
        &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        sc_data = data[&#34;sc_data&#34;]
        working_days = basic_ILP_vars[&#34;working_days&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
                &#34;numberOfConsecutiveDaysOff&#34;
            ]
            max_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;maximumNumberOfConsecutiveDaysOffHard&#34;]
            for d in all_days:
                if d &gt; max_consecutive_working_days:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                working_days[n][d - max_consecutive_working_days: d + 1],
                                [1] * (max_consecutive_working_days + 1),
                            )
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )
                else:
                    if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                            ],
                            senses=[&#34;G&#34;],
                            rhs=[1],
                        )

    def add_total_assignments_with_if_needed_skill_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes any assigment of nurse using a skill that is labeled as &#34;if needed&#34;.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_days = data[&#34;all_days&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
        total_assignments_with_if_needed_skill = soft_ILP_vars[
            &#34;total_assignments_with_if_needed_skill&#34;
        ]

        for n in all_nurses:
            if len(nurses_data[n][&#34;skillsIfNeeded&#34;]) &gt; 0:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [total_assignments_with_if_needed_skill[(n)]]
                            + [
                                shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                                for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                                for s in all_shifts
                                for d in all_days
                            ],
                            [-1]
                            + [1]
                            * len(
                                [
                                    shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                                    for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                                    for s in all_shifts
                                    for d in all_days
                                ]
                            ),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    def add_total_unsatisfied_overtime_constraints_soft(
        self, model, basic_ILP_vars, soft_ILP_vars, data
    ):
        &#34;&#34;&#34;Adds the soft constraint that penilizes unsatisfied wanted overtime per assignment.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        all_nurses = data[&#34;all_nurses&#34;]
        num_weeks = data[&#34;num_weeks&#34;]
        h0_data = data[&#34;h0_data&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_unsatisfied_overtime = soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;]

        for n in all_nurses:
            if data[&#34;configuration&#34;][&#34;h12&#34;] and (
                n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
            ):
                continue

            if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] == 0):
                continue

            worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
                &#34;numberOfAssignments&#34;
            ]
            upper_limit = math.ceil(
                (
                    contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                        &#34;maximumNumberOfAssignments&#34;
                    ]
                    + nurses_data[n][&#34;wantedOvertime&#34;]
                )
                * ((week_number + 1) / num_weeks)
            )
            lower_limit = math.ceil(
                (
                    contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                        &#34;maximumNumberOfAssignments&#34;
                    ]
                    + nurses_data[n][&#34;wantedOvertime&#34;]
                )
                * ((week_number + 1) / num_weeks)
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_over_limit[(n)], total_assignments[(n)]],
                        [-1, 1],
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[upper_limit - worked_days_in_previous_weeks],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_unsatisfied_overtime[(n)], total_assignments[(n)]],
                        [1, 1],
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[lower_limit - worked_days_in_previous_weeks],
            )

    def add_soft_constraints(self, model, basic_ILP_vars, soft_ILP_vars, data):
        &#34;&#34;&#34;Adds the soft constraints to the model.

        Args:
            model : object that represents the mathematical model
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
            data (dict): dictionary that contains data from input files
        &#34;&#34;&#34;
        if data[&#34;configuration&#34;][&#34;s1&#34;]:
            self.add_shift_skill_req_optimal_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s2&#34;]:
            self.add_min_consecutive_shifts_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_max_consecutive_work_days_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_max_consecutive_work_shifts_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_min_consecutive_work_days_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s3&#34;]:
            self.add_max_consecutive_days_off_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )
            self.add_min_consecutive_days_off_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s4&#34;]:
            self.add_insatisfied_preferences_reqs_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s6&#34;]:
            self.add_total_assignments_out_of_bounds_constraint_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s7&#34;]:
            self.add_total_working_weekends_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s8&#34;]:
            self.add_total_assignments_with_if_needed_skill_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        if data[&#34;configuration&#34;][&#34;s9&#34;]:
            self.add_total_unsatisfied_overtime_constraints_soft(
                model, basic_ILP_vars, soft_ILP_vars, data
            )

        # add_incomplete_weekends_constraint_soft(self, model, basic_ILP_vars, soft_ILP_vars, data)

    def save_tmp_results(self, results, sol, data, basic_ILP_vars, soft_ILP_vars):
        &#34;&#34;&#34;Stores the solution into the results dictionary.

        Args:
            results (dict): dictionary used to store partially computed schedule
            sol (_type_): _description_
            data (dict): dictionary that contains data from input files
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
        &#34;&#34;&#34;
        num_days = data[&#34;num_days&#34;]
        num_nurses = data[&#34;num_nurses&#34;]
        num_skills = data[&#34;num_skills&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

        shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

        if not sol.is_primal_feasible():
            return

        results[(week_number, &#34;status&#34;)] = utils.STATUS_OK
        print(&#34;obj. value: &#34; + str(sol.get_objective_value()))

        for n in range(num_nurses):
            for d in range(num_days):
                for s in range(num_shifts):
                    for sk in range(num_skills):
                        results[(n, d + 7 * week_number, s, sk)] = round(
                            sol.get_values(shifts_with_skills[n][d][s][sk])
                        )

    def set_objective_function(self, model, data, basic_ILP_vars, soft_ILP_vars):
        &#34;&#34;&#34;Sets the objective function contatining all penalties from all enabled constraints.

        Args:
            model : object that represents the mathematical model
            data (dict): dictionary that contains data from input files
            basic_ILP_vars (dict): contains the names variables of the mathematical model
            soft_ILP_vars (dict): contains the names variables of the mathematical model
        &#34;&#34;&#34;
        all_nurses = data[&#34;all_nurses&#34;]
        all_shifts = data[&#34;all_shifts&#34;]
        all_skills = data[&#34;all_skills&#34;]
        all_days = data[&#34;all_days&#34;]

        sc_data = data[&#34;sc_data&#34;]

        num_nurses = data[&#34;num_nurses&#34;]
        num_shifts = data[&#34;num_shifts&#34;]
        num_skills = data[&#34;num_skills&#34;]
        num_days = data[&#34;num_days&#34;]

        insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]
        unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
        total_working_weekends_over_limit = soft_ILP_vars[
            &#34;total_working_weekends_over_limit&#34;
        ]
        incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
        total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
        total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
        violations_of_max_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_days&#34;
        ]
        violations_of_max_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_max_consecutive_working_shifts&#34;
        ]
        violations_of_max_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_max_consecutive_days_off&#34;
        ]
        violations_of_min_consecutive_working_days = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_days&#34;
        ]
        violations_of_min_consecutive_days_off = soft_ILP_vars[
            &#34;violations_of_min_consecutive_days_off&#34;
        ]
        violations_of_min_consecutive_working_shifts = soft_ILP_vars[
            &#34;violations_of_min_consecutive_working_shifts&#34;
        ]
        total_assignments_with_if_needed_skill = soft_ILP_vars[
            &#34;total_assignments_with_if_needed_skill&#34;
        ]

        model.objective.set_sense(model.objective.sense.minimize)

        summed_violations_of_min_cons_working_days = []
        weights_of_violations_of_min_cons_working_days = []
        for n in all_nurses:
            min_consecutive_working_days = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_working_days):
                    summed_violations_of_min_cons_working_days.append(
                        violations_of_min_consecutive_working_days[(n, d, dd)]
                    )
                    weights_of_violations_of_min_cons_working_days.append(30 * dd)

        summed_violations_of_min_cons_days_off = []
        weights_of_violations_of_min_cons_days_off = []
        for n in all_nurses:
            min_consecutive_days_off = sc_data[&#34;contracts&#34;][
                utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
            ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
            for d in all_days:
                for dd in range(1, min_consecutive_days_off):
                    summed_violations_of_min_cons_days_off.append(
                        violations_of_min_consecutive_days_off[(n, d, dd)]
                    )
                    weights_of_violations_of_min_cons_days_off.append(30 * dd)

        summed_violations_of_min_cons_shift_type = []
        weights_of_violations_of_min_cons_shift_type = []
        for n in all_nurses:
            for d in all_days:
                for s in all_shifts:
                    min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                        &#34;minimumNumberOfConsecutiveAssignments&#34;
                    ]
                    for dd in range(1, min_consecutive_shifts):
                        summed_violations_of_min_cons_shift_type.append(
                            violations_of_min_consecutive_working_shifts[(n, d, s, dd)]
                        )
                        weights_of_violations_of_min_cons_shift_type.append(15 * dd)

        model.objective.set_linear(
            list(
                itertools.chain.from_iterable(
                    [
                        zip(
                            (
                                insufficient_staffing[(d, s, sk)]
                                for d in all_days
                                for s in all_shifts
                                for sk in all_skills
                            ),
                            [30] * num_days * num_shifts * num_skills,
                        ),
                        zip(
                            (
                                unsatisfied_preferences[(n, d, s)]
                                for n in all_nurses
                                for d in all_days
                                for s in all_shifts
                            ),
                            [10] * num_nurses * num_days * num_shifts,
                        ),
                        zip(
                            (total_working_weekends_over_limit[(n)] for n in all_nurses),
                            [30] * num_nurses,
                        ),
                        zip(
                            (incomplete_weekends[(n)] for n in all_nurses),
                            [30] * num_nurses,
                        ),
                        zip(
                            (total_assignments_over_limit[(n)] for n in all_nurses),
                            [20] * num_nurses,
                        ),
                        zip(
                            (total_assignments_under_limit[(n)] for n in all_nurses),
                            [20] * num_nurses,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_working_days[(n, d)]
                                for n in all_nurses
                                for d in all_days
                            ),
                            [30] * num_nurses * num_days,
                        ),
                        zip(
                            summed_violations_of_min_cons_working_days,
                            weights_of_violations_of_min_cons_working_days,
                        ),
                        zip(
                            summed_violations_of_min_cons_days_off,
                            weights_of_violations_of_min_cons_days_off,
                        ),
                        zip(
                            summed_violations_of_min_cons_shift_type,
                            weights_of_violations_of_min_cons_shift_type,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_days_off[(n, d)]
                                for n in all_nurses
                                for d in all_days
                            ),
                            [30] * num_nurses * num_days,
                        ),
                        zip(
                            (
                                violations_of_max_consecutive_working_shifts[(n, d, s)]
                                for n in all_nurses
                                for d in all_days
                                for s in all_shifts
                            ),
                            [15] * num_nurses * num_days * num_shifts,
                        ),
                        zip(
                            (
                                total_assignments_with_if_needed_skill[(n)]
                                for n in all_nurses
                            ),
                            [15] * num_nurses,
                        ),
                    ]
                )
            )
        )

        return

    def setup_problem(self, model, data, results):
        &#34;&#34;&#34;Sets up the mathematical model to be solved.

        Args:
            model : object that represents the mathematical model
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule

        Returns:
            (dict, dict): 2 dictionaries that contains names of variables of the mathematical model
        &#34;&#34;&#34;
        self.prepare_help_data(data, results)

        # Create ILP variables.
        basic_ILP_vars = self.init_ilp_vars(model, data)

        # Add hard constrains to model
        self.add_hard_constrains(model, basic_ILP_vars, data)

        # soft_ILP_vars = {}
        soft_ILP_vars = self.init_ilp_vars_for_soft_constraints(model, basic_ILP_vars, data)

        self.add_soft_constraints(model, basic_ILP_vars, soft_ILP_vars, data)

        self.set_objective_function(model, data, basic_ILP_vars, soft_ILP_vars)

        return basic_ILP_vars, soft_ILP_vars

    def compute_one_week(self, time_limit_for_week, data, results):
        &#34;&#34;&#34;Computes a schedule for a week given a time limit and data.

        Args:
            time_limit_for_week (int): time limit for finding a schedule as optimal as possible
            data (dict): dictionary that contains data from input files
            results (dict): dictionary used to store partially computed schedule
        &#34;&#34;&#34;
        model = cplex.Cplex()
        model.parameters.mip.display.set(0)
        model.parameters.output.clonelog.set(0)
        # c.set_log_stream(&#34;log.txt&#34;)
        model.parameters.simplex.display.set(0)
        model.parameters.threads.set(1)
        model.parameters.timelimit.set(time_limit_for_week)
        model.parameters.mip.tolerances.absmipgap.set(0.0)
        model.parameters.emphasis.mip.set(model.parameters.emphasis.mip.values.optimality)

        basic_ILP_vars, soft_ILP_vars = self.setup_problem(model, data, results)

        model.solve()
        sol = model.solution
        print(sol.get_method())
        print(f&#34;number of threads: {model.parameters.threads.get()}&#34;)

        self.save_tmp_results(results, sol, data, basic_ILP_vars, soft_ILP_vars)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nsp_solver.solver.nsp_solver.NSP_solver" href="nsp_solver.html#nsp_solver.solver.nsp_solver.NSP_solver">NSP_solver</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_hard_constrains"><code class="name flex">
<span>def <span class="ident">add_hard_constrains</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds all hard constraints to the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>data</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_hard_constrains(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds all hard constraints to the model.

    Args:
        model (_type_): _description_
        basic_ILP_vars (_type_): _description_
        data (_type_): _description_
    &#34;&#34;&#34;

    if data[&#34;configuration&#34;][&#34;h1&#34;]:
        self.add_max_one_shift_per_day_constraint(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h2&#34;]:
        self.add_shift_skill_req_minimal(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h3&#34;]:
        self.add_shift_succession_reqs(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h4&#34;]:
        self.add_missing_skill_req(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h5&#34;]:
        self.add_max_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
        self.add_max_consecutive_work_shifts_constraint_hard(
            model, basic_ILP_vars, data
        )
        self.add_min_consecutive_work_days_constraint_hard(model, basic_ILP_vars, data)
        self.add_min_consecutive_shifts_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h6&#34;]:
        self.add_max_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)
        self.add_min_consecutive_days_off_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h7&#34;]:
        self.add_max_incomplete_weekends_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h8&#34;]:
        self.add_max_min_total_assignments_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h9&#34;]:
        self.add_min_continuous_free_period_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h10&#34;]:
        self.add_max_one_shift_per_day_exception_constraint_hard(
            model, basic_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;h11&#34;]:
        self.add_max_shift_of_given_type_constraint_hard(model, basic_ILP_vars, data)

    if data[&#34;configuration&#34;][&#34;h12&#34;]:
        self.add_vacations_reqs_constraint_hard(model, basic_ILP_vars, data)</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_incomplete_weekends_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_incomplete_weekends_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes incomplete weekends.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_incomplete_weekends_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
    incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
    working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    all_nurses = data[&#34;all_nurses&#34;]

    for n in all_nurses:
        isCompleteWeekendRequested = contracts_data[
            utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
        ][&#34;completeWeekends&#34;]
        if isCompleteWeekendRequested == 1:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            incomplete_weekends[(n)],
                            working_weekends[(n)],
                            working_days[n][5],
                            working_days[n][6],
                        ],
                        [-1, 2, -1, -1],
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_insatisfied_preferences_reqs_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_insatisfied_preferences_reqs_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that introduces the preferences of nurses for specific assignments/non-assignments.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_insatisfied_preferences_reqs_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that introduces the preferences of nurses for specific assignments/non-assignments.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    wd_data = data[&#34;wd_data&#34;]

    for preference in wd_data[&#34;shiftOffRequests&#34;]:
        nurse_id = int(preference[&#34;nurse&#34;].split(&#34;_&#34;)[1])
        day_id = utils.day_to_int[preference[&#34;day&#34;]]
        shift_id = utils.shift_to_int[preference[&#34;shiftType&#34;]]

        if shift_id != utils.shift_to_int[&#34;Any&#34;]:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            unsatisfied_preferences[(nurse_id, day_id, shift_id)],
                            shifts[nurse_id][day_id][shift_id],
                        ],
                        [1, -1],
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )
        else:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            unsatisfied_preferences[(nurse_id, day_id, 0)],
                            working_days[nurse_id][day_id],
                        ],
                        [1, -1],
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_days_off_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue

        consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveDaysOff&#34;
        ]
        max_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfConsecutiveDaysOffHard&#34;]
        for d in all_days:
            if d &gt; max_consecutive_working_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            working_days[n][d - max_consecutive_working_days: d + 1],
                            [1] * (max_consecutive_working_days + 1),
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[1],
                )
            else:
                if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_days_off_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_days_off_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that bans assignment of any number of consecutive days off over the maximum specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_max_consecutive_days_off = soft_ILP_vars[
        &#34;violations_of_max_consecutive_days_off&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveDaysOff&#34;
        ]
        max_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfConsecutiveDaysOff&#34;]
        for d in all_days:
            if d &gt; max_consecutive_working_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [violations_of_max_consecutive_days_off[(n, d)]]
                            + working_days[n][d - max_consecutive_working_days: d + 1],
                            [1] + [1] * (max_consecutive_working_days + 1),
                        )
                    ],
                    senses=[&#34;G&#34;],
                    rhs=[1],
                )
            else:
                if consecutive_days_off_prev_week &gt;= max_consecutive_working_days - d:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_days_off[(n, d)]]
                                + working_days[n][0: d + 1],
                                [1] + [1] * (d + 1),
                            )
                        ],
                        senses=[&#34;G&#34;],
                        rhs=[1],
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_work_days_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans assignment of any number of consecutive working days over the maximum specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive working days over the maximum specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveWorkingDays&#34;
        ]
        max_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfConsecutiveWorkingDaysHard&#34;]
        for d in all_days:
            if d &gt; max_consecutive_working_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            working_days[n][d - max_consecutive_working_days: d + 1],
                            [1] * (max_consecutive_working_days + 1),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[max_consecutive_working_days],
                )
            else:
                if (
                    consecutive_working_days_prev_week
                    &gt;= max_consecutive_working_days - d
                ):
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(working_days[n][0: d + 1], [1] * (d + 1))
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[d],
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_work_days_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes assignment of a number of consecutive working days over the maximum specified in the constract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_work_days_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive working days over the maximum specified in the constract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_max_consecutive_working_days = soft_ILP_vars[
        &#34;violations_of_max_consecutive_working_days&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveWorkingDays&#34;
        ]
        max_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfConsecutiveWorkingDays&#34;]
        for d in all_days:
            if d &gt; max_consecutive_working_days:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [violations_of_max_consecutive_working_days[(n, d)]]
                            + working_days[n][d - max_consecutive_working_days: d + 1],
                            [-1] + [1] * (max_consecutive_working_days + 1),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[max_consecutive_working_days],
                )
            else:
                if (
                    consecutive_working_days_prev_week
                    &gt;= max_consecutive_working_days - d
                ):
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_max_consecutive_working_days[(n, d)]]
                                + working_days[n][0: d + 1],
                                [-1] + [1] * (d + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[d],
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_work_shifts_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_work_shifts_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    sc_data = data[&#34;sc_data&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]

    for n in all_nurses:
        last_shift = utils.shift_to_int[
            data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
        ]
        consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveAssignments&#34;
        ]
        for s in all_shifts:
            max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                &#34;maximumNumberOfConsecutiveAssignmentsHard&#34;
            ]
            for d in all_days:
                if d &gt; max_consecutive_working_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                list(
                                    shifts[n][d - dd][s]
                                    for dd in range(1 + max_consecutive_working_shifts)
                                ),
                                [1] * (max_consecutive_working_shifts + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_shifts],
                    )
                else:
                    if (last_shift == s) and (
                        consecutive_shifts_prev_week
                        &gt;= max_consecutive_working_shifts - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    list(shifts[n][dd][s] for dd in range(d + 1)),
                                    [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_max_consecutive_work_shifts_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_consecutive_work_shifts_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of any number of consecutive shifts of one type over the maximum specified in the scenario.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_max_consecutive_working_shifts = soft_ILP_vars[
        &#34;violations_of_max_consecutive_working_shifts&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    sc_data = data[&#34;sc_data&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]

    for n in all_nurses:
        last_shift = utils.shift_to_int[
            data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
        ]
        consecutive_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveAssignments&#34;
        ]
        for s in all_shifts:
            max_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                &#34;maximumNumberOfConsecutiveAssignments&#34;
            ]
            for d in all_days:
                if d &gt; max_consecutive_working_shifts:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [
                                    violations_of_max_consecutive_working_shifts[
                                        (n, d, s)
                                    ]
                                ]
                                + list(
                                    shifts[n][d - dd][s]
                                    for dd in range(1 + max_consecutive_working_shifts)
                                ),
                                [-1] + [1] * (max_consecutive_working_shifts + 1),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[max_consecutive_working_shifts],
                    )
                else:
                    if (last_shift == s) and (
                        consecutive_shifts_prev_week
                        &gt;= max_consecutive_working_shifts - d
                    ):
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        violations_of_max_consecutive_working_shifts[
                                            (n, d, s)
                                        ]
                                    ]
                                    + list(shifts[n][dd][s] for dd in range(d + 1)),
                                    [-1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_incomplete_weekends_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_incomplete_weekends_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes incomplete weekends.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_incomplete_weekends_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the soft constraint that penilizes incomplete weekends.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

    for n in all_nurses:
        incomplete_weekends_prev = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfIncompleteWeekends&#34;
        ]
        max_incomplete_weekends = contracts_data[
            utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfIncompleteWeekendsHard&#34;]
        model.linear_constraints.add(
            lin_expr=[cplex.SparsePair([incomplete_weekends[(n)]], [1])],
            senses=[&#34;L&#34;],
            rhs=[max_incomplete_weekends - incomplete_weekends_prev],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_min_total_assignments_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_min_total_assignments_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that enforces that total number of assignemnts a nurse are in the limits specified in the contract of the nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_min_total_assignments_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that enforces that total number of assignemnts a nurse are in the limits specified in the contract of the nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
    num_weeks = data[&#34;num_weeks&#34;]
    total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
    all_nurses = data[&#34;all_nurses&#34;]
    h0_data = data[&#34;h0_data&#34;]
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue

        worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
            &#34;numberOfAssignments&#34;
        ]
        upper_limit = math.ceil(
            contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                &#34;maximumNumberOfAssignmentsHard&#34;
            ]
            * ((week_number + 1) / num_weeks)
        )
        lower_limit = contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
            &#34;minimumNumberOfAssignmentsHard&#34;
        ]

        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_assignments[(n)]],
                    [1],
                )
            ],
            senses=[&#34;L&#34;],
            rhs=[upper_limit - worked_days_in_previous_weeks],
        )

        if (week_number + 1) == num_weeks:
            model.linear_constraints.add(
                lin_expr=[cplex.SparsePair([total_assignments[(n)]], [1])],
                senses=[&#34;G&#34;],
                rhs=[lower_limit - worked_days_in_previous_weeks],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_constraint"><code class="name flex">
<span>def <span class="ident">add_max_one_shift_per_day_constraint</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans multiple assignments of a nurse on one day.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_one_shift_per_day_constraint(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    all_days = data[&#34;all_days&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

    # Each nurse works at most one shift per day.
    for n in all_nurses:
        for d in all_days:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(shifts[n][d][:], [1] * len(shifts[n][d][:]))
                ],
                senses=[&#34;L&#34;],
                rhs=[1],
            )

    # Each nurse works at most one skill per shift.
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            shifts_with_skills[n][d][s][:],
                            [1] * len(shifts_with_skills[n][d][s][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

    # If nurse is working with skill that shift, she is working that shift.
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                            [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )

    # If nurse is working with a shift, she is working that day.
    for n in all_nurses:
        for d in all_days:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [working_days[n][d]] + shifts[n][d][:],
                        [-1] + [1] * len(shifts[n][d][:]),
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_exception_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_one_shift_per_day_exception_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans multiple assignments of a nurse on one day with the exception of early and night shifts on the same day.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_one_shift_per_day_exception_constraint_hard(
    self, model, basic_ILP_vars, data
):
    &#34;&#34;&#34;Adds the hard constraint that bans multiple assignments of a nurse on one day with the exception of early and night shifts on the same day.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    all_days = data[&#34;all_days&#34;]
    num_shifts = data[&#34;num_shifts&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

    # Each nurse works at most one shift per day with an exception early + night.
    for n in all_nurses:
        for d in all_days:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        shifts[n][d][0: (num_shifts - 1)], [1] * (num_shifts - 1)
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[1],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(shifts[n][d][1:num_shifts], [1] * (num_shifts - 1))
                ],
                senses=[&#34;L&#34;],
                rhs=[1],
            )

    # If nurse is working with a shift, she is working that day.
    for n in all_nurses:
        for d in all_days:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [working_days[n][d]] + shifts[n][d][:],
                        [-4] + [1] * len(shifts[n][d][:]),
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[0],
            )
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [working_days[n][d]] + shifts[n][d][:],
                        [1] + [-2] * len(shifts[n][d][:]),
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[0],
            )

    # Each nurse works at most one skill per shift.
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            shifts_with_skills[n][d][s][:],
                            [1] * len(shifts_with_skills[n][d][s][:]),
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

    # If nurse is working with skill that shift, she is working that shift.
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [shifts[n][d][s]] + shifts_with_skills[n][d][s][:],
                            [-1] + [1] * len(shifts_with_skills[n][d][s][:]),
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[0],
                )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_shift_of_given_type_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_max_shift_of_given_type_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that disallows more assignments to a specific shift type than it is allowed.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max_shift_of_given_type_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that disallows more assignments to a specific shift type than it is allowed.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    num_days = data[&#34;num_days&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]

    for n in all_nurses:
        already_assigned = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numbersOfAssignedRestrictedShiftTypes&#34;
        ]
        for restriction in data[&#34;sc_data&#34;][&#34;nurses&#34;][n][&#34;restrictions&#34;]:
            shift_id = utils.shift_to_int[restriction[&#34;type&#34;]]
            limit = restriction[&#34;limit&#34;]
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [shifts[n][d][shift_id] for d in all_days], [1] * num_days
                    )
                ],
                senses=[&#34;L&#34;],
                rhs=[limit - already_assigned[shift_id][&#34;numberOfAssignments&#34;]],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_days_off_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that bans any number of consecutive days off under the minimum specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_days_off_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the soft constraint that bans any number of consecutive days off under the minimum specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue
        consecutive_days_off_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveDaysOff&#34;
        ]
        min_consecutive_days_off = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveDaysOffHard&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_days_off):
                if (d - dd) &gt; 0:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [working_days[n][d]]
                                + list(
                                    not_working_days[(n, ddd)]
                                    for ddd in range(d - dd, d)
                                )
                                + [working_days[n][d - dd - 1]],
                                [1] * (dd + 2),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[dd + 1],
                    )
                else:
                    if consecutive_days_off_prev_week == d - dd:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(0, d)
                                    ),
                                    [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_days_off_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes a number of consecutive days off under the minimum specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_days_off_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes a number of consecutive days off under the minimum specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_min_consecutive_days_off = soft_ILP_vars[
        &#34;violations_of_min_consecutive_days_off&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

    for n in all_nurses:
        consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveDaysOff&#34;
        ]
        min_consecutive_days_off = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_days_off):
                if (d - dd) &gt; 0:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                + [working_days[n][d]]
                                + list(
                                    not_working_days[(n, ddd)]
                                    for ddd in range(d - dd, d)
                                )
                                + [working_days[n][d - dd - 1]],
                                [-1] + [1] * (dd + 2),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[dd + 1],
                    )
                else:
                    if consecutive_working_days_prev_week == d - dd:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [violations_of_min_consecutive_days_off[(n, d, dd)]]
                                    + [working_days[n][d]]
                                    + list(
                                        not_working_days[(n, ddd)]
                                        for ddd in range(0, d)
                                    ),
                                    [-1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_shifts_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_shifts_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    sc_data = data[&#34;sc_data&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]
    not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue
        consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveAssignments&#34;
        ]
        lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;lastAssignedShiftType&#34;
        ]
        lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
        for d in all_days:
            for s in all_shifts:
                min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;minimumNumberOfConsecutiveAssignmentsHard&#34;
                ]
                for dd in range(1, min_consecutive_shifts):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [not_working_shifts[(n, d, s)]]
                                    + list(
                                        (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                    )
                                    + [not_working_shifts[(n, d - dd - 1, s)]],
                                    [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if (consecutive_working_shifts_prev_week == dd - d) and (
                            lastShittTypeAsInt == s
                            or consecutive_working_shifts_prev_week == 0
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [not_working_shifts[(n, d, s)]]
                                        + list((shifts[n][ddd][s]) for ddd in range(d)),
                                        [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )
                    if (d - dd) == 0 and lastShittTypeAsInt != s:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [not_working_shifts[(n, d, s)]]
                                    + list(
                                        (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                    ),
                                    # + [not_working_shifts[(n, d - dd - 1, s)]],
                                    [1] * (dd + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_shifts_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_shifts_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes assignment of a number of consecutive shifts of one type under the minimum specified in the scenario.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_min_consecutive_working_shifts = soft_ILP_vars[
        &#34;violations_of_min_consecutive_working_shifts&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    sc_data = data[&#34;sc_data&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]
    not_working_shifts = basic_ILP_vars[&#34;not_working_shifts&#34;]

    for n in all_nurses:
        consecutive_working_shifts_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveAssignments&#34;
        ]
        lastAssignedShiftType = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;lastAssignedShiftType&#34;
        ]
        lastShittTypeAsInt = utils.shift_to_int[lastAssignedShiftType]
        for d in all_days:
            for s in all_shifts:
                min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;minimumNumberOfConsecutiveAssignments&#34;
                ]
                for dd in range(1, min_consecutive_shifts):
                    if (d - dd) &gt; 0:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        violations_of_min_consecutive_working_shifts[
                                            (n, d, s, dd)
                                        ]
                                    ]
                                    + [not_working_shifts[(n, d, s)]]
                                    + list(
                                        (shifts[n][ddd][s]) for ddd in range(d - dd, d)
                                    )
                                    + [not_working_shifts[(n, d - dd - 1, s)]],
                                    [-1] + [1] * (dd + 2),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[dd + 1],
                        )
                    else:
                        if (consecutive_working_shifts_prev_week == dd - d) and (
                            lastShittTypeAsInt == s
                        ):
                            model.linear_constraints.add(
                                lin_expr=[
                                    cplex.SparsePair(
                                        [
                                            violations_of_min_consecutive_working_shifts[
                                                (n, d, s, dd)
                                            ]
                                        ]
                                        + [not_working_shifts[(n, d, s)]]
                                        + list((shifts[n][ddd][s]) for ddd in range(d)),
                                        [-1] + [1] * (d + 1),
                                    )
                                ],
                                senses=[&#34;L&#34;],
                                rhs=[d],
                            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_work_days_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_work_days_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;
    Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue

        consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveWorkingDays&#34;
        ]
        min_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveWorkingDaysHard&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_working_days):
                if (d - dd) &gt; 0:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [not_working_days[(n, d)]]
                                + working_days[n][d - dd: d]
                                + [not_working_days[(n, d - dd - 1)]],
                                [1] * (dd + 2),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[dd + 1],
                    )
                else:
                    if consecutive_working_days_prev_week == dd - d:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [not_working_days[(n, d)]] + working_days[n][0:d],
                                    [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_min_consecutive_work_days_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_consecutive_work_days_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;
    Adds the soft constraint that penilizes assignment of a number of consecutive working days under the minimum specified in the constract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    violations_of_min_consecutive_working_days = soft_ILP_vars[
        &#34;violations_of_min_consecutive_working_days&#34;
    ]
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    sc_data = data[&#34;sc_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]
    not_working_days = basic_ILP_vars[&#34;not_working_days&#34;]

    for n in all_nurses:
        consecutive_working_days_prev_week = data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][
            &#34;numberOfConsecutiveWorkingDays&#34;
        ]
        min_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_working_days):
                if (d - dd) &gt; 0:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [violations_of_min_consecutive_working_days[(n, d, dd)]]
                                + [not_working_days[(n, d)]]
                                + working_days[n][d - dd: d]
                                + [not_working_days[(n, d - dd - 1)]],
                                [-1] + [1] * (dd + 2),
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[dd + 1],
                    )
                else:
                    if consecutive_working_days_prev_week == d - dd:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair(
                                    [
                                        violations_of_min_consecutive_working_days[
                                            (n, d, dd)
                                        ]
                                    ]
                                    + [not_working_days[(n, d)]]
                                    + working_days[n][0:d],
                                    [-1] + [1] * (d + 1),
                                )
                            ],
                            senses=[&#34;L&#34;],
                            rhs=[d],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_continuous_free_period_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_min_continuous_free_period_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that enforces that every nurse has a minimal continuous period of days off.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_min_continuous_free_period_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that enforces that every nurse has a minimal continuous period of days off.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    num_days = data[&#34;num_days&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
        contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
        min_free_period = contracts_data[
            utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
        ][&#34;minimalFreePeriod&#34;]

        vars_to_add = []
        free_periods = {}
        for d in range(num_days - min_free_period + 1):
            var_name = f&#34;free_period_of_{min_free_period}_days_n{n}_d{d}&#34;
            vars_to_add.append(var_name)
            free_periods[(n, d)] = var_name
        model.variables.add(
            names=vars_to_add,
            lb=[0] * len(vars_to_add),
            ub=[1] * len(vars_to_add),
            types=[&#34;N&#34;] * len(vars_to_add),
        )

        for d in range(num_days - min_free_period + 1):
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [free_periods[(n, d)]]
                        + working_days[n][d: d + min_free_period],
                        [1] + [1] * min_free_period,
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[0],
            )

            for dd in range(d, d + min_free_period):
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [free_periods[(n, d)]] + [working_days[n][dd]],
                            [1] + [1],
                        )
                    ],
                    senses=[&#34;L&#34;],
                    rhs=[1],
                )

        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [
                        free_periods[(n, d)]
                        for d in range(num_days - min_free_period + 1)
                    ],
                    [1] * (num_days - min_free_period + 1),
                )
            ],
            senses=[&#34;G&#34;],
            rhs=[1],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_missing_skill_req"><code class="name flex">
<span>def <span class="ident">add_missing_skill_req</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds hard constraint that disables nurses working shift with a skill that they do not possess.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>data</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_missing_skill_req(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds hard constraint that disables nurses working shift with a skill that they do not possess.

    Args:
        model (_type_): _description_
        basic_ILP_vars (_type_): _description_
        data (_type_): _description_
    &#34;&#34;&#34;

    all_shifts = data[&#34;all_shifts&#34;]
    all_days = data[&#34;all_days&#34;]
    all_skills = data[&#34;all_skills&#34;]
    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

    for n, nurse_data in enumerate(nurses_data):
        for sk in all_skills:
            has_skill = False
            for skill in nurse_data[&#34;skills&#34;]:
                if sk == utils.skill_to_int[skill]:
                    has_skill = True
                    break
            if has_skill is False:
                for d in all_days:
                    for s in all_shifts:
                        model.linear_constraints.add(
                            lin_expr=[
                                cplex.SparsePair([shifts_with_skills[n][d][s][sk]], [1])
                            ],
                            senses=[&#34;E&#34;],
                            rhs=[0],
                        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_minimal"><code class="name flex">
<span>def <span class="ident">add_shift_skill_req_minimal</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds hard constraint that dictates minimal number of nurses in a shift working with specific skill.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>data</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shift_skill_req_minimal(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds hard constraint that dictates minimal number of nurses in a shift working with specific skill.

    Args:
        model (_type_): _description_
        basic_ILP_vars (_type_): _description_
        data (_type_): _description_
    &#34;&#34;&#34;

    all_nurses = data[&#34;all_nurses&#34;]
    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

    for req in data[&#34;wd_data&#34;][&#34;requirements&#34;]:

        s = utils.shift_to_int[req[&#34;shiftType&#34;]]
        sk = utils.skill_to_int[req[&#34;skill&#34;]]
        minimal_capacities_in_week = [
            req[&#34;requirementOnMonday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnTuesday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnWednesday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnThursday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnFriday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnSaturday&#34;][&#34;minimum&#34;],
            req[&#34;requirementOnSunday&#34;][&#34;minimum&#34;],
        ]

        for d, min_capacity in enumerate(minimal_capacities_in_week):
            skills_worked = []
            for n in all_nurses:
                skills_worked.append(shifts_with_skills[n][d][s][sk])
            model.linear_constraints.add(
                lin_expr=[cplex.SparsePair(skills_worked, [1] * len(skills_worked))],
                senses=[&#34;G&#34;],
                rhs=[min_capacity],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_optimal_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_shift_skill_req_optimal_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that introduces the optimal number of assigned nurses for each combination of day, shift, skill.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shift_skill_req_optimal_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that introduces the optimal number of assigned nurses for each combination of day, shift, skill.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
    insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]

    wd_data = data[&#34;wd_data&#34;]

    for req in wd_data[&#34;requirements&#34;]:
        s = utils.shift_to_int[req[&#34;shiftType&#34;]]
        sk = utils.skill_to_int[req[&#34;skill&#34;]]
        optimal_capacities_in_week = [
            req[&#34;requirementOnMonday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnTuesday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnWednesday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnThursday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnFriday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnSaturday&#34;][&#34;optimal&#34;],
            req[&#34;requirementOnSunday&#34;][&#34;optimal&#34;],
        ]

        for d, opt_capacity in enumerate(optimal_capacities_in_week):
            skills_worked = []
            for n in all_nurses:
                skills_worked.append(shifts_with_skills[n][d][s][sk])
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [insufficient_staffing[(d, s, sk)]] + skills_worked,
                        [1] + [1] * len(skills_worked),
                    )
                ],
                senses=[&#34;G&#34;],
                rhs=[opt_capacity],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_succession_reqs"><code class="name flex">
<span>def <span class="ident">add_shift_succession_reqs</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds hard constraint that disables invalid pairs of succcessive shift types.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shift_succession_reqs(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;
    Adds hard constraint that disables invalid pairs of succcessive shift types.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;

    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    num_days = data[&#34;num_days&#34;]
    shifts = basic_ILP_vars[&#34;shifts&#34;]

    for n in all_nurses:
        last_shift = utils.shift_to_int[
            data[&#34;h0_data&#34;][&#34;nurseHistory&#34;][n][&#34;lastAssignedShiftType&#34;]
        ]
        if last_shift == 2:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [shifts[n][0][last_shift - 1], shifts[n][0][last_shift - 2]],
                        [1] * 2,
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )
        if last_shift == 3:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            shifts[n][0][last_shift - 1],
                            shifts[n][0][last_shift - 2],
                            shifts[n][0][last_shift - 3],
                        ],
                        [1] * 3,
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

        for d in range(num_days - 1):
            for s in all_shifts:
                if s == 2:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [
                                    shifts[n][d][s],
                                    shifts[n][d + 1][s - 1],
                                    shifts[n][d + 1][s - 2],
                                ],
                                [1] * 3,
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )
                if s == 3:
                    model.linear_constraints.add(
                        lin_expr=[
                            cplex.SparsePair(
                                [
                                    shifts[n][d][s],
                                    shifts[n][d + 1][s - 1],
                                    shifts[n][d + 1][s - 2],
                                    shifts[n][d + 1][s - 3],
                                ],
                                [1] * 4,
                            )
                        ],
                        senses=[&#34;L&#34;],
                        rhs=[1],
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_soft_constraints"><code class="name flex">
<span>def <span class="ident">add_soft_constraints</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraints to the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_soft_constraints(self, model, basic_ILP_vars, soft_ILP_vars, data):
    &#34;&#34;&#34;Adds the soft constraints to the model.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    if data[&#34;configuration&#34;][&#34;s1&#34;]:
        self.add_shift_skill_req_optimal_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s2&#34;]:
        self.add_min_consecutive_shifts_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )
        self.add_max_consecutive_work_days_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )
        self.add_max_consecutive_work_shifts_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )
        self.add_min_consecutive_work_days_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s3&#34;]:
        self.add_max_consecutive_days_off_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )
        self.add_min_consecutive_days_off_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s4&#34;]:
        self.add_insatisfied_preferences_reqs_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s6&#34;]:
        self.add_total_assignments_out_of_bounds_constraint_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s7&#34;]:
        self.add_total_working_weekends_constraints_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s8&#34;]:
        self.add_total_assignments_with_if_needed_skill_constraints_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    if data[&#34;configuration&#34;][&#34;s9&#34;]:
        self.add_total_unsatisfied_overtime_constraints_soft(
            model, basic_ILP_vars, soft_ILP_vars, data
        )

    # add_incomplete_weekends_constraint_soft(self, model, basic_ILP_vars, soft_ILP_vars, data)</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_out_of_bounds_constraint_soft"><code class="name flex">
<span>def <span class="ident">add_total_assignments_out_of_bounds_constraint_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes total assignments out of bounds specified in the contract of each nurse.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_total_assignments_out_of_bounds_constraint_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes total assignments out of bounds specified in the contract of each nurse.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
    total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
    total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
    total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
    all_nurses = data[&#34;all_nurses&#34;]
    num_weeks = data[&#34;num_weeks&#34;]
    h0_data = data[&#34;h0_data&#34;]
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue

        if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] &gt; 0):
            continue

        worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
            &#34;numberOfAssignments&#34;
        ]
        upper_limit = math.ceil(
            contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                &#34;maximumNumberOfAssignments&#34;
            ]
            * ((week_number + 1) / num_weeks)
        )
        lower_limit = math.ceil(
            contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                &#34;minimumNumberOfAssignments&#34;
            ]
            * ((week_number + 1) / num_weeks)
        )
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_assignments_over_limit[(n)], total_assignments[(n)]],
                    [-1, 1],
                )
            ],
            senses=[&#34;L&#34;],
            rhs=[upper_limit - worked_days_in_previous_weeks],
        )
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_assignments_under_limit[(n)], total_assignments[(n)]],
                    [1, 1],
                )
            ],
            senses=[&#34;G&#34;],
            rhs=[lower_limit - worked_days_in_previous_weeks],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_with_if_needed_skill_constraints_soft"><code class="name flex">
<span>def <span class="ident">add_total_assignments_with_if_needed_skill_constraints_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes any assigment of nurse using a skill that is labeled as "if needed".</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_total_assignments_with_if_needed_skill_constraints_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes any assigment of nurse using a skill that is labeled as &#34;if needed&#34;.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_days = data[&#34;all_days&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]

    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]
    total_assignments_with_if_needed_skill = soft_ILP_vars[
        &#34;total_assignments_with_if_needed_skill&#34;
    ]

    for n in all_nurses:
        if len(nurses_data[n][&#34;skillsIfNeeded&#34;]) &gt; 0:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [total_assignments_with_if_needed_skill[(n)]]
                        + [
                            shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                            for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                            for s in all_shifts
                            for d in all_days
                        ],
                        [-1]
                        + [1]
                        * len(
                            [
                                shifts_with_skills[n][d][s][utils.skill_to_int[sk]]
                                for sk in nurses_data[n][&#34;skillsIfNeeded&#34;]
                                for s in all_shifts
                                for d in all_days
                            ]
                        ),
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_unsatisfied_overtime_constraints_soft"><code class="name flex">
<span>def <span class="ident">add_total_unsatisfied_overtime_constraints_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes unsatisfied wanted overtime per assignment.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_total_unsatisfied_overtime_constraints_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes unsatisfied wanted overtime per assignment.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    total_assignments = basic_ILP_vars[&#34;total_assignments&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]
    all_nurses = data[&#34;all_nurses&#34;]
    num_weeks = data[&#34;num_weeks&#34;]
    h0_data = data[&#34;h0_data&#34;]
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
    total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
    total_unsatisfied_overtime = soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;]

    for n in all_nurses:
        if data[&#34;configuration&#34;][&#34;h12&#34;] and (
            n in data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;]
        ):
            continue

        if data[&#34;configuration&#34;][&#34;s9&#34;] and (nurses_data[n][&#34;wantedOvertime&#34;] == 0):
            continue

        worked_days_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
            &#34;numberOfAssignments&#34;
        ]
        upper_limit = math.ceil(
            (
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignments&#34;
                ]
                + nurses_data[n][&#34;wantedOvertime&#34;]
            )
            * ((week_number + 1) / num_weeks)
        )
        lower_limit = math.ceil(
            (
                contracts_data[utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]][
                    &#34;maximumNumberOfAssignments&#34;
                ]
                + nurses_data[n][&#34;wantedOvertime&#34;]
            )
            * ((week_number + 1) / num_weeks)
        )
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_assignments_over_limit[(n)], total_assignments[(n)]],
                    [-1, 1],
                )
            ],
            senses=[&#34;L&#34;],
            rhs=[upper_limit - worked_days_in_previous_weeks],
        )
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_unsatisfied_overtime[(n)], total_assignments[(n)]],
                    [1, 1],
                )
            ],
            senses=[&#34;G&#34;],
            rhs=[lower_limit - worked_days_in_previous_weeks],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_working_weekends_constraints_soft"><code class="name flex">
<span>def <span class="ident">add_total_working_weekends_constraints_soft</span></span>(<span>self, model, basic_ILP_vars, soft_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the soft constraint that penilizes more working weekends than the specified maximum.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_total_working_weekends_constraints_soft(
    self, model, basic_ILP_vars, soft_ILP_vars, data
):
    &#34;&#34;&#34;Adds the soft constraint that penilizes more working weekends than the specified maximum.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]
    sc_data = data[&#34;sc_data&#34;]
    h0_data = data[&#34;h0_data&#34;]
    total_working_weekends_over_limit = soft_ILP_vars[
        &#34;total_working_weekends_over_limit&#34;
    ]
    working_weekends = basic_ILP_vars[&#34;working_weekends&#34;]

    all_nurses = data[&#34;all_nurses&#34;]
    num_weeks = data[&#34;num_weeks&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for n in all_nurses:
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair([working_weekends[(n)], working_days[n][5]], [1, -1])
            ],
            senses=[&#34;G&#34;],
            rhs=[0],
        )
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair([working_weekends[(n)], working_days[n][6]], [1, -1])
            ],
            senses=[&#34;G&#34;],
            rhs=[0],
        )

    for n in all_nurses:
        worked_weekends_limit_for_this_week = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;maximumNumberOfWorkingWeekends&#34;] * ((week_number + 1) / num_weeks)
        worked_weekends_in_previous_weeks = h0_data[&#34;nurseHistory&#34;][n][
            &#34;numberOfWorkingWeekends&#34;
        ]
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_working_weekends_over_limit[(n)], working_weekends[(n)]],
                    [-1, 1],
                )
            ],
            senses=[&#34;L&#34;],
            rhs=[
                worked_weekends_limit_for_this_week - worked_weekends_in_previous_weeks
            ],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.add_vacations_reqs_constraint_hard"><code class="name flex">
<span>def <span class="ident">add_vacations_reqs_constraint_hard</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the hard constraint that bans assignments fot a nurse that is has planned a vacation.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vacations_reqs_constraint_hard(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the hard constraint that bans assignments fot a nurse that is has planned a vacation.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files
    &#34;&#34;&#34;
    wd_data = data[&#34;wd_data&#34;]
    working_days = basic_ILP_vars[&#34;working_days&#34;]

    for nurse_id in wd_data[&#34;vacations_with_ids&#34;]:
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    working_days[nurse_id][:], [1] * len(working_days[nurse_id][:])
                )
            ],
            senses=[&#34;E&#34;],
            rhs=[0],
        )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars"><code class="name flex">
<span>def <span class="ident">init_ilp_vars</span></span>(<span>self, model, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes basic variables for primarly for hard contraints.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>object that represents the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dictionary 'basic_ILP_vars' that contains the names variables of the mathematical model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ilp_vars(self, model, data):
    &#34;&#34;&#34;
    Initializes basic variables for primarly for hard contraints.

    Args:
        model: object that represents the mathematical model
        data (dict): dictionary that contains data from input files

    Returns:
        dict: dictionary &#39;basic_ILP_vars&#39; that contains the names variables of the mathematical model
    &#34;&#34;&#34;

    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    all_days = data[&#34;all_days&#34;]
    all_skills = data[&#34;all_skills&#34;]
    num_days = data[&#34;num_days&#34;]
    nurses_data = data[&#34;sc_data&#34;][&#34;nurses&#34;]
    contracts_data = data[&#34;sc_data&#34;][&#34;contracts&#34;]

    # Creates shifts variables.
    # shifts[n][d][s]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; if 1 does not work if 0.
    vars_to_add = []
    shifts = []
    for n in all_nurses:
        shifts.append([])
        for d in all_days:
            shifts[n].append([])
            for s in all_shifts:
                var_name = f&#34;shift_n{n}_d{d}_s{s}&#34;
                vars_to_add.append(var_name)
                shifts[n][d].append(var_name)

    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    # Creates working_days variables.
    # shifts[n][d][s]: nurse &#39;n&#39; works on day &#39;d&#39; if 1 does not work if 0.
    vars_to_add = []
    working_days = []
    for n in all_nurses:
        working_days.append([])
        for d in all_days:
            var_name = f&#34;work_day_n{n}_d{d}&#34;
            working_days[n].append(var_name)
            vars_to_add.append(var_name)

    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    # Creates shifts_with_skills variables.
    # shifts_with_skills[(n, d, s, sk)]: nurse &#39;n&#39; works shift &#39;s&#39; on day &#39;d&#39; with skill &#39;sk&#39;.
    vars_to_add = []
    shifts_with_skills = []
    for n in all_nurses:
        shifts_with_skills.append([])
        for d in all_days:
            shifts_with_skills[n].append([])
            for s in all_shifts:
                shifts_with_skills[n][d].append([])
                for sk in all_skills:
                    var_name = f&#34;shift_with_skill_n{n}_d{d}_s{s}_sk{sk}&#34;
                    vars_to_add.append(var_name)
                    shifts_with_skills[n][d][s].append(var_name)

    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    not_working_days = {}
    for n in all_nurses:
        for d in all_days:
            var_name = f&#34;not_working_day_n{n}_d{d}&#34;
            not_working_days[(n, d)] = var_name
            vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    for n in all_nurses:
        for d in all_days:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [not_working_days[(n, d)], working_days[n][d]], [1, 1]
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[1],
            )

    vars_to_add = []
    not_working_shifts = {}
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                var_name = f&#34;not_workingshift_n{n}_d{d}_s{s}&#34;
                vars_to_add.append(var_name)
                not_working_shifts[(n, d, s)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                model.linear_constraints.add(
                    lin_expr=[
                        cplex.SparsePair(
                            [not_working_shifts[(n, d, s)], shifts[n][d][s]], [1, 1]
                        )
                    ],
                    senses=[&#34;E&#34;],
                    rhs=[1],
                )

    # Vars for each nurse how many days they worked
    vars_to_add = []
    total_assignments = {}
    for n in all_nurses:
        var_name = f&#34;total_assignments_n{n}&#34;
        total_assignments[(n)] = var_name
        vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[num_days + 1] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    for n in all_nurses:
        model.linear_constraints.add(
            lin_expr=[
                cplex.SparsePair(
                    [total_assignments[(n)]]
                    + [shifts[n][d][s] for d in all_days for s in all_shifts],
                    [-1]
                    + [1]
                    * len([shifts[n][d][s] for d in all_days for s in all_shifts]),
                )
            ],
            senses=[&#34;E&#34;],
            rhs=[0],
        )

    # Vars for each nurse n indicationg if they were working on weekend this week
    vars_to_add = []
    working_weekends = {}
    for n in all_nurses:
        var_name = f&#34;working_weekends_n{n}&#34;
        working_weekends[(n)] = var_name
        vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    incomplete_weekends = {}
    for n in all_nurses:
        var_name = f&#34;incomplete_weekends_n{n}&#34;
        vars_to_add.append(var_name)
        incomplete_weekends[(n)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    for n in all_nurses:
        isCompleteWeekendRequested = contracts_data[
            utils.contract_to_int[nurses_data[n][&#34;contract&#34;]]
        ][&#34;completeWeekends&#34;]
        if isCompleteWeekendRequested == 1:
            model.linear_constraints.add(
                lin_expr=[
                    cplex.SparsePair(
                        [
                            incomplete_weekends[(n)],
                            working_weekends[(n)],
                            working_days[n][5],
                            working_days[n][6],
                        ],
                        [-1, 2, -1, -1],
                    )
                ],
                senses=[&#34;E&#34;],
                rhs=[0],
            )

    basic_ILP_vars = {}
    basic_ILP_vars[&#34;working_days&#34;] = working_days
    basic_ILP_vars[&#34;incomplete_weekends&#34;] = incomplete_weekends
    basic_ILP_vars[&#34;total_assignments&#34;] = total_assignments
    basic_ILP_vars[&#34;working_weekends&#34;] = working_weekends
    basic_ILP_vars[&#34;not_working_days&#34;] = not_working_days
    basic_ILP_vars[&#34;not_working_shifts&#34;] = not_working_shifts
    basic_ILP_vars[&#34;shifts&#34;] = shifts
    basic_ILP_vars[&#34;shifts_with_skills&#34;] = shifts_with_skills
    return basic_ILP_vars</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars_for_soft_constraints"><code class="name flex">
<span>def <span class="ident">init_ilp_vars_for_soft_constraints</span></span>(<span>self, model, basic_ILP_vars, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the variables used for soft constraints to the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dic</code></dt>
<dd>dictionary that contains the names of introduced variables</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ilp_vars_for_soft_constraints(self, model, basic_ILP_vars, data):
    &#34;&#34;&#34;Adds the variables used for soft constraints to the model.

    Args:
        model : object that represents the mathematical model
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        data (dict): dictionary that contains data from input files

    Returns:
        dic: dictionary that contains the names of introduced variables
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    all_skills = data[&#34;all_skills&#34;]
    all_days = data[&#34;all_days&#34;]
    num_weeks = data[&#34;num_weeks&#34;]
    sc_data = data[&#34;sc_data&#34;]

    # Creates insufficient staffing variables.
    # shifts[(d,s,sk)]: number of nurses under optimal number for day d shift s and skill sk
    vars_to_add = []
    insufficient_staffing = {}
    for d in all_days:
        for s in all_shifts:
            for sk in all_skills:
                var_name = f&#34;insufficient_staffing_d{d}_s{s}_sk{sk}&#34;
                vars_to_add.append(var_name)
                insufficient_staffing[(d, s, sk)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[10] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    # Creates unsatisfied preferences variables.
    # unsatisfied_preferences_n{n}_d{d}_s{s} of nurse n for day d and shift s
    vars_to_add = []
    unsatisfied_preferences = {}
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                var_name = f&#34;unsatisfied_preferences_n{n}_d{d}_s{s}&#34;
                vars_to_add.append(var_name)
                unsatisfied_preferences[(n, d, s)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    # Vars for each nurse n indicationg if how many weekends were they working up to this week over the limit
    vars_to_add = []
    total_working_weekends_over_limit = {}
    for n in all_nurses:
        var_name = f&#34;total_working_weekends_over_limit_n{n}&#34;
        total_working_weekends_over_limit[(n)] = var_name
        vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[num_weeks] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    total_assignments_over_limit = {}
    total_assignments_under_limit = {}
    for n in all_nurses:
        var_name1, var_name2 = (
            f&#34;total_assignments_over_limit_n{n}&#34;,
            f&#34;total_assignments_under_limit_n{n}&#34;,
        )
        total_assignments_over_limit[(n)] = var_name1
        total_assignments_under_limit[(n)] = var_name2
        vars_to_add.append(var_name1)
        vars_to_add.append(var_name2)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[7] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_max_consecutive_working_days = {}
    for n in all_nurses:
        for d in all_days:
            var_name = f&#34;violations_of_max_consecutive_working_days_n{n}_d{d}&#34;
            vars_to_add.append(var_name)
            violations_of_max_consecutive_working_days[(n, d)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_max_consecutive_working_shifts = {}
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                var_name = (
                    f&#34;violations_of_max_consecutive_working_shifts_n{n}_d{d}_s{s}&#34;
                )
                violations_of_max_consecutive_working_shifts[(n, d, s)] = var_name
                vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_max_consecutive_days_off = {}
    for n in all_nurses:
        for d in all_days:
            var_name = f&#34;violations_of_max_consecutive_days_off_n{n}_d{d}&#34;
            vars_to_add.append(var_name)
            violations_of_max_consecutive_days_off[(n, d)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_min_consecutive_days_off = {}
    for n in all_nurses:
        min_consecutive_days_off = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_days_off):
                var_name = f&#34;violations_of_min_consecutive_days_off_n{n}_d{d}_dd{dd}&#34;
                vars_to_add.append(var_name)
                violations_of_min_consecutive_days_off[(n, d, dd)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_min_consecutive_working_days = {}
    for n in all_nurses:
        min_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_working_days):
                var_name = (
                    f&#34;violations_of_min_consecutive_working_days_n{n}_d{d}_dd{dd}&#34;
                )
                vars_to_add.append(var_name)
                violations_of_min_consecutive_working_days[(n, d, dd)] = var_name
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    violations_of_min_consecutive_working_shifts = {}
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                min_consecutive_working_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;minimumNumberOfConsecutiveAssignments&#34;
                ]
                for dd in range(1, min_consecutive_working_shifts):
                    var_name = f&#34;violations_of_min_consecutive_working_shifts_n{n}_d{d}_s{s}_dd{dd}&#34;
                    violations_of_min_consecutive_working_shifts[(n, d, s, dd)] = (
                        var_name
                    )
                    vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[1] * len(vars_to_add),
        types=[&#34;B&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    total_assignments_with_if_needed_skill = {}
    for n in all_nurses:
        var_name = f&#34;total_assignments_with_if_needed_skill_n{n}&#34;
        total_assignments_with_if_needed_skill[(n)] = var_name
        vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[28] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    vars_to_add = []
    total_unsatisfied_overtime = {}
    for n in all_nurses:
        var_name = f&#34;total_unsatisfied_overtime_n{n}&#34;
        total_unsatisfied_overtime[(n)] = var_name
        vars_to_add.append(var_name)
    model.variables.add(
        names=vars_to_add,
        lb=[0] * len(vars_to_add),
        ub=[7] * len(vars_to_add),
        types=[&#34;N&#34;] * len(vars_to_add),
    )

    soft_ILP_vars = {}
    soft_ILP_vars[&#34;insufficient_staffing&#34;] = insufficient_staffing
    soft_ILP_vars[&#34;total_unsatisfied_overtime&#34;] = total_unsatisfied_overtime
    soft_ILP_vars[&#34;total_assignments_with_if_needed_skill&#34;] = (
        total_assignments_with_if_needed_skill
    )
    soft_ILP_vars[&#34;unsatisfied_preferences&#34;] = unsatisfied_preferences
    soft_ILP_vars[&#34;total_working_weekends_over_limit&#34;] = (
        total_working_weekends_over_limit
    )
    soft_ILP_vars[&#34;total_assignments_over_limit&#34;] = total_assignments_over_limit
    soft_ILP_vars[&#34;total_assignments_under_limit&#34;] = total_assignments_under_limit
    soft_ILP_vars[&#34;violations_of_max_consecutive_working_days&#34;] = (
        violations_of_max_consecutive_working_days
    )
    soft_ILP_vars[&#34;violations_of_max_consecutive_days_off&#34;] = (
        violations_of_max_consecutive_days_off
    )
    soft_ILP_vars[&#34;violations_of_max_consecutive_working_shifts&#34;] = (
        violations_of_max_consecutive_working_shifts
    )
    soft_ILP_vars[&#34;violations_of_min_consecutive_working_days&#34;] = (
        violations_of_min_consecutive_working_days
    )
    soft_ILP_vars[&#34;violations_of_min_consecutive_days_off&#34;] = (
        violations_of_min_consecutive_days_off
    )
    soft_ILP_vars[&#34;violations_of_min_consecutive_working_shifts&#34;] = (
        violations_of_min_consecutive_working_shifts
    )

    return soft_ILP_vars</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.prepare_help_data"><code class="name flex">
<span>def <span class="ident">prepare_help_data</span></span>(<span>self, data, results)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares helpful data for other methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary used to store partially computed schedule</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_help_data(self, data, results):
    &#34;&#34;&#34;Prepares helpful data for other methods.

    Args:
        data (dict): dictionary that contains data from input files
        results (dict): dictionary used to store partially computed schedule
    &#34;&#34;&#34;
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

    data[&#34;wd_data&#34;][&#34;vacations_with_ids&#34;] = list(
        map(lambda x: int(x.split(&#34;_&#34;)[1]), data[&#34;wd_data&#34;][&#34;vacations&#34;])
    )

    results[(week_number, &#34;status&#34;)] = utils.STATUS_FAIL</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.save_tmp_results"><code class="name flex">
<span>def <span class="ident">save_tmp_results</span></span>(<span>self, results, sol, data, basic_ILP_vars, soft_ILP_vars)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the solution into the results dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary used to store partially computed schedule</dd>
<dt><strong><code>sol</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_tmp_results(self, results, sol, data, basic_ILP_vars, soft_ILP_vars):
    &#34;&#34;&#34;Stores the solution into the results dictionary.

    Args:
        results (dict): dictionary used to store partially computed schedule
        sol (_type_): _description_
        data (dict): dictionary that contains data from input files
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
    &#34;&#34;&#34;
    num_days = data[&#34;num_days&#34;]
    num_nurses = data[&#34;num_nurses&#34;]
    num_skills = data[&#34;num_skills&#34;]
    num_shifts = data[&#34;num_shifts&#34;]
    week_number = data[&#34;h0_data&#34;][&#34;week&#34;]

    shifts_with_skills = basic_ILP_vars[&#34;shifts_with_skills&#34;]

    if not sol.is_primal_feasible():
        return

    results[(week_number, &#34;status&#34;)] = utils.STATUS_OK
    print(&#34;obj. value: &#34; + str(sol.get_objective_value()))

    for n in range(num_nurses):
        for d in range(num_days):
            for s in range(num_shifts):
                for sk in range(num_skills):
                    results[(n, d + 7 * week_number, s, sk)] = round(
                        sol.get_values(shifts_with_skills[n][d][s][sk])
                    )</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.set_objective_function"><code class="name flex">
<span>def <span class="ident">set_objective_function</span></span>(<span>self, model, data, basic_ILP_vars, soft_ILP_vars)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the objective function contatining all penalties from all enabled constraints.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
<dt><strong><code>basic_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
<dt><strong><code>soft_ILP_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains the names variables of the mathematical model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_objective_function(self, model, data, basic_ILP_vars, soft_ILP_vars):
    &#34;&#34;&#34;Sets the objective function contatining all penalties from all enabled constraints.

    Args:
        model : object that represents the mathematical model
        data (dict): dictionary that contains data from input files
        basic_ILP_vars (dict): contains the names variables of the mathematical model
        soft_ILP_vars (dict): contains the names variables of the mathematical model
    &#34;&#34;&#34;
    all_nurses = data[&#34;all_nurses&#34;]
    all_shifts = data[&#34;all_shifts&#34;]
    all_skills = data[&#34;all_skills&#34;]
    all_days = data[&#34;all_days&#34;]

    sc_data = data[&#34;sc_data&#34;]

    num_nurses = data[&#34;num_nurses&#34;]
    num_shifts = data[&#34;num_shifts&#34;]
    num_skills = data[&#34;num_skills&#34;]
    num_days = data[&#34;num_days&#34;]

    insufficient_staffing = soft_ILP_vars[&#34;insufficient_staffing&#34;]
    unsatisfied_preferences = soft_ILP_vars[&#34;unsatisfied_preferences&#34;]
    total_working_weekends_over_limit = soft_ILP_vars[
        &#34;total_working_weekends_over_limit&#34;
    ]
    incomplete_weekends = basic_ILP_vars[&#34;incomplete_weekends&#34;]
    total_assignments_over_limit = soft_ILP_vars[&#34;total_assignments_over_limit&#34;]
    total_assignments_under_limit = soft_ILP_vars[&#34;total_assignments_under_limit&#34;]
    violations_of_max_consecutive_working_days = soft_ILP_vars[
        &#34;violations_of_max_consecutive_working_days&#34;
    ]
    violations_of_max_consecutive_working_shifts = soft_ILP_vars[
        &#34;violations_of_max_consecutive_working_shifts&#34;
    ]
    violations_of_max_consecutive_days_off = soft_ILP_vars[
        &#34;violations_of_max_consecutive_days_off&#34;
    ]
    violations_of_min_consecutive_working_days = soft_ILP_vars[
        &#34;violations_of_min_consecutive_working_days&#34;
    ]
    violations_of_min_consecutive_days_off = soft_ILP_vars[
        &#34;violations_of_min_consecutive_days_off&#34;
    ]
    violations_of_min_consecutive_working_shifts = soft_ILP_vars[
        &#34;violations_of_min_consecutive_working_shifts&#34;
    ]
    total_assignments_with_if_needed_skill = soft_ILP_vars[
        &#34;total_assignments_with_if_needed_skill&#34;
    ]

    model.objective.set_sense(model.objective.sense.minimize)

    summed_violations_of_min_cons_working_days = []
    weights_of_violations_of_min_cons_working_days = []
    for n in all_nurses:
        min_consecutive_working_days = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveWorkingDays&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_working_days):
                summed_violations_of_min_cons_working_days.append(
                    violations_of_min_consecutive_working_days[(n, d, dd)]
                )
                weights_of_violations_of_min_cons_working_days.append(30 * dd)

    summed_violations_of_min_cons_days_off = []
    weights_of_violations_of_min_cons_days_off = []
    for n in all_nurses:
        min_consecutive_days_off = sc_data[&#34;contracts&#34;][
            utils.contract_to_int[sc_data[&#34;nurses&#34;][n][&#34;contract&#34;]]
        ][&#34;minimumNumberOfConsecutiveDaysOff&#34;]
        for d in all_days:
            for dd in range(1, min_consecutive_days_off):
                summed_violations_of_min_cons_days_off.append(
                    violations_of_min_consecutive_days_off[(n, d, dd)]
                )
                weights_of_violations_of_min_cons_days_off.append(30 * dd)

    summed_violations_of_min_cons_shift_type = []
    weights_of_violations_of_min_cons_shift_type = []
    for n in all_nurses:
        for d in all_days:
            for s in all_shifts:
                min_consecutive_shifts = sc_data[&#34;shiftTypes&#34;][s][
                    &#34;minimumNumberOfConsecutiveAssignments&#34;
                ]
                for dd in range(1, min_consecutive_shifts):
                    summed_violations_of_min_cons_shift_type.append(
                        violations_of_min_consecutive_working_shifts[(n, d, s, dd)]
                    )
                    weights_of_violations_of_min_cons_shift_type.append(15 * dd)

    model.objective.set_linear(
        list(
            itertools.chain.from_iterable(
                [
                    zip(
                        (
                            insufficient_staffing[(d, s, sk)]
                            for d in all_days
                            for s in all_shifts
                            for sk in all_skills
                        ),
                        [30] * num_days * num_shifts * num_skills,
                    ),
                    zip(
                        (
                            unsatisfied_preferences[(n, d, s)]
                            for n in all_nurses
                            for d in all_days
                            for s in all_shifts
                        ),
                        [10] * num_nurses * num_days * num_shifts,
                    ),
                    zip(
                        (total_working_weekends_over_limit[(n)] for n in all_nurses),
                        [30] * num_nurses,
                    ),
                    zip(
                        (incomplete_weekends[(n)] for n in all_nurses),
                        [30] * num_nurses,
                    ),
                    zip(
                        (total_assignments_over_limit[(n)] for n in all_nurses),
                        [20] * num_nurses,
                    ),
                    zip(
                        (total_assignments_under_limit[(n)] for n in all_nurses),
                        [20] * num_nurses,
                    ),
                    zip(
                        (
                            violations_of_max_consecutive_working_days[(n, d)]
                            for n in all_nurses
                            for d in all_days
                        ),
                        [30] * num_nurses * num_days,
                    ),
                    zip(
                        summed_violations_of_min_cons_working_days,
                        weights_of_violations_of_min_cons_working_days,
                    ),
                    zip(
                        summed_violations_of_min_cons_days_off,
                        weights_of_violations_of_min_cons_days_off,
                    ),
                    zip(
                        summed_violations_of_min_cons_shift_type,
                        weights_of_violations_of_min_cons_shift_type,
                    ),
                    zip(
                        (
                            violations_of_max_consecutive_days_off[(n, d)]
                            for n in all_nurses
                            for d in all_days
                        ),
                        [30] * num_nurses * num_days,
                    ),
                    zip(
                        (
                            violations_of_max_consecutive_working_shifts[(n, d, s)]
                            for n in all_nurses
                            for d in all_days
                            for s in all_shifts
                        ),
                        [15] * num_nurses * num_days * num_shifts,
                    ),
                    zip(
                        (
                            total_assignments_with_if_needed_skill[(n)]
                            for n in all_nurses
                        ),
                        [15] * num_nurses,
                    ),
                ]
            )
        )
    )

    return</code></pre>
</details>
</dd>
<dt id="nsp_solver.solver.nsp_cplex.CplexSolver.setup_problem"><code class="name flex">
<span>def <span class="ident">setup_problem</span></span>(<span>self, model, data, results)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the mathematical model to be solved.</p>
<h2 id="args">Args</h2>
<dl>
<dt>model : object that represents the mathematical model</dt>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary that contains data from input files</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary used to store partially computed schedule</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(dict, dict): 2 dictionaries that contains names of variables of the mathematical model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_problem(self, model, data, results):
    &#34;&#34;&#34;Sets up the mathematical model to be solved.

    Args:
        model : object that represents the mathematical model
        data (dict): dictionary that contains data from input files
        results (dict): dictionary used to store partially computed schedule

    Returns:
        (dict, dict): 2 dictionaries that contains names of variables of the mathematical model
    &#34;&#34;&#34;
    self.prepare_help_data(data, results)

    # Create ILP variables.
    basic_ILP_vars = self.init_ilp_vars(model, data)

    # Add hard constrains to model
    self.add_hard_constrains(model, basic_ILP_vars, data)

    # soft_ILP_vars = {}
    soft_ILP_vars = self.init_ilp_vars_for_soft_constraints(model, basic_ILP_vars, data)

    self.add_soft_constraints(model, basic_ILP_vars, soft_ILP_vars, data)

    self.set_objective_function(model, data, basic_ILP_vars, soft_ILP_vars)

    return basic_ILP_vars, soft_ILP_vars</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nsp_solver.solver.nsp_solver.NSP_solver" href="nsp_solver.html#nsp_solver.solver.nsp_solver.NSP_solver">NSP_solver</a></b></code>:
<ul class="hlist">
<li><code><a title="nsp_solver.solver.nsp_solver.NSP_solver.compute_one_week" href="nsp_solver.html#nsp_solver.solver.nsp_solver.NSP_solver.compute_one_week">compute_one_week</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nsp_solver.solver" href="index.html">nsp_solver.solver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver" href="#nsp_solver.solver.nsp_cplex.CplexSolver">CplexSolver</a></code></h4>
<ul class="">
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_hard_constrains" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_hard_constrains">add_hard_constrains</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_incomplete_weekends_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_incomplete_weekends_constraint_soft">add_incomplete_weekends_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_insatisfied_preferences_reqs_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_insatisfied_preferences_reqs_constraint_soft">add_insatisfied_preferences_reqs_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_hard">add_max_consecutive_days_off_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_days_off_constraint_soft">add_max_consecutive_days_off_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_hard">add_max_consecutive_work_days_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_days_constraint_soft">add_max_consecutive_work_days_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_hard">add_max_consecutive_work_shifts_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_consecutive_work_shifts_constraint_soft">add_max_consecutive_work_shifts_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_incomplete_weekends_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_incomplete_weekends_constraint_hard">add_max_incomplete_weekends_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_min_total_assignments_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_min_total_assignments_constraint_hard">add_max_min_total_assignments_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_constraint" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_constraint">add_max_one_shift_per_day_constraint</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_exception_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_one_shift_per_day_exception_constraint_hard">add_max_one_shift_per_day_exception_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_max_shift_of_given_type_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_max_shift_of_given_type_constraint_hard">add_max_shift_of_given_type_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_hard">add_min_consecutive_days_off_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_days_off_constraint_soft">add_min_consecutive_days_off_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_hard">add_min_consecutive_shifts_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_shifts_constraint_soft">add_min_consecutive_shifts_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_hard">add_min_consecutive_work_days_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_consecutive_work_days_constraint_soft">add_min_consecutive_work_days_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_min_continuous_free_period_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_min_continuous_free_period_constraint_hard">add_min_continuous_free_period_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_missing_skill_req" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_missing_skill_req">add_missing_skill_req</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_minimal" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_minimal">add_shift_skill_req_minimal</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_optimal_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_skill_req_optimal_constraint_soft">add_shift_skill_req_optimal_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_succession_reqs" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_shift_succession_reqs">add_shift_succession_reqs</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_soft_constraints" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_soft_constraints">add_soft_constraints</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_out_of_bounds_constraint_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_out_of_bounds_constraint_soft">add_total_assignments_out_of_bounds_constraint_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_with_if_needed_skill_constraints_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_total_assignments_with_if_needed_skill_constraints_soft">add_total_assignments_with_if_needed_skill_constraints_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_unsatisfied_overtime_constraints_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_total_unsatisfied_overtime_constraints_soft">add_total_unsatisfied_overtime_constraints_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_total_working_weekends_constraints_soft" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_total_working_weekends_constraints_soft">add_total_working_weekends_constraints_soft</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.add_vacations_reqs_constraint_hard" href="#nsp_solver.solver.nsp_cplex.CplexSolver.add_vacations_reqs_constraint_hard">add_vacations_reqs_constraint_hard</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars" href="#nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars">init_ilp_vars</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars_for_soft_constraints" href="#nsp_solver.solver.nsp_cplex.CplexSolver.init_ilp_vars_for_soft_constraints">init_ilp_vars_for_soft_constraints</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.name" href="#nsp_solver.solver.nsp_cplex.CplexSolver.name">name</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.prepare_help_data" href="#nsp_solver.solver.nsp_cplex.CplexSolver.prepare_help_data">prepare_help_data</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.save_tmp_results" href="#nsp_solver.solver.nsp_cplex.CplexSolver.save_tmp_results">save_tmp_results</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.set_objective_function" href="#nsp_solver.solver.nsp_cplex.CplexSolver.set_objective_function">set_objective_function</a></code></li>
<li><code><a title="nsp_solver.solver.nsp_cplex.CplexSolver.setup_problem" href="#nsp_solver.solver.nsp_cplex.CplexSolver.setup_problem">setup_problem</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>